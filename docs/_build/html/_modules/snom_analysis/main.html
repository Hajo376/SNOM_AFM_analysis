

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>snom_analysis.main &mdash; SNOM Analysis 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            SNOM Analysis
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Readme</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../snom_analysis.html">snom_analysis package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SNOM Analysis</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">snom_analysis.main</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for snom_analysis.main</h1><div class="highlight"><pre>
<span></span><span class="sd">&#39;&#39;&#39;This module contains the basic classes and functions for the snom analysis.&#39;&#39;&#39;</span>

<span class="c1">##########################################################################</span>
<span class="c1"># This code was created by Hans-Joachim Schill, University of Bonn, 2022 #</span>
<span class="c1">##########################################################################</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">gaussian_filter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">struct</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.axes_grid1</span><span class="w"> </span><span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mpl_point_clicker</span><span class="w"> </span><span class="kn">import</span> <span class="n">clicker</span><span class="c1"># used for getting coordinates from images</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib_scalebar.scalebar</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScaleBar</span> <span class="c1"># used for creating scale bars</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">patches</span> <span class="c1"># used for creating rectangles </span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span><span class="p">,</span> <span class="n">PurePath</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pkl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ast</span> <span class="c1"># for string to list, dict ... conversion</span>
<span class="c1"># for gif creation</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">imageio</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.animation</span><span class="w"> </span><span class="kn">import</span> <span class="n">FuncAnimation</span>
<span class="c1"># for old version</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">PIL</span><span class="w"> </span><span class="kn">import</span> <span class="n">Image</span>
<span class="c1"># for config file</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">configparser</span><span class="w"> </span><span class="kn">import</span> <span class="n">ConfigParser</span>

<span class="c1"># import own functionality</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.snom_colormaps</span><span class="w"> </span><span class="kn">import</span> <span class="n">SNOM_height</span><span class="p">,</span> <span class="n">SNOM_amplitude</span><span class="p">,</span> <span class="n">SNOM_phase</span><span class="p">,</span> <span class="n">SNOM_realpart</span><span class="p">,</span> <span class="n">all_colormaps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.phase_slider</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_phase_offset</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.rectangle_selector</span><span class="w"> </span><span class="kn">import</span> <span class="n">select_rectangle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.data_range_selector</span><span class="w"> </span><span class="kn">import</span> <span class="n">select_data_range</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.get_directionality</span><span class="w"> </span><span class="kn">import</span> <span class="n">ChiralCoupler</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">realign</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">profile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">phase_analysis</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.file_handling</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_parameter_values</span><span class="p">,</span> <span class="n">find_index</span><span class="p">,</span> <span class="n">convert_header_to_dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lib.profile_selector</span><span class="w"> </span><span class="kn">import</span> <span class="n">select_profile</span>

<span class="c1"># keep this for internal referencing</span>
<div class="viewcode-block" id="Definitions">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Definitions">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Definitions</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">vertical</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>


<div class="viewcode-block" id="MeasurementTags">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.MeasurementTags">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MeasurementTags</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class keeps track of the implemented measurement tags. </span>
<span class="sd">    These are tags wich are measurement specific.</span>
<span class="sd">    Only tags which are listed here can be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SCAN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
    <span class="n">PROJECT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">DESCRIPTION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">DATE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">SCANNERCENTERPOSITION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">ROTATION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">SCANAREA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  
    <span class="n">PIXELAREA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">AVERAGING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">INTEGRATIONTIME</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">LASERSOURCE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">DETECTOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">TARGETWAVELENGTH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>    
    <span class="n">DEMODULATIONMODE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">TIPFREQUENCY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">TIPAMPLITUTDE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">TAPPINGAMPLITUDE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">MODULATIONFREQUENCY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">MODULATIONAMPLITUDE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">MODULATIONOFFSET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">SETPOINT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">REGULATOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">TIPPOTENTIAL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">M1ASCALING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  
    <span class="n">QFACTOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">VERSION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   </div>


<div class="viewcode-block" id="ChannelTags">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ChannelTags">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ChannelTags</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class keeps track of the implemented channel tags.</span>
<span class="sd">    These are tags which are channel specific.</span>
<span class="sd">    So multiple channels might have varying channel tag values but</span>
<span class="sd">    they will share the same measurement tag values. However, the </span>
<span class="sd">    current channel tag values are always to prefer over the same measurement tag value.</span>
<span class="sd">    As the channel tag values change when the channel is manipulated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">PIXELAREA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  
    <span class="n">YINCOMPLETE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span> 
    <span class="n">SCANNERCENTERPOSITION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">ROTATION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   
    <span class="n">SCANAREA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  
    <span class="n">XYUNIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ZUNIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">WAVENUMBERSCALING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="c1"># additional tags</span>
    <span class="n">PIXELSCALING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>

    <span class="c1"># additional for aachen files (.dump)</span>
    <span class="c1"># INTEGRATIONTIME = auto()</span>
    <span class="c1"># TIPFREQUENCY = auto()</span>
    <span class="c1"># MODULATIONFREQUENCY = auto()</span>
    <span class="c1"># TAPPINGAMPLITUDE = auto()</span>
    <span class="c1"># MODULATIONOFFSET = auto()</span>
    <span class="c1"># SETPOINT = auto()</span>
    
    
    

<div class="viewcode-block" id="PlotDefinitions">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.PlotDefinitions">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">PlotDefinitions</span><span class="p">:</span>
    <span class="n">hide_ticks</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">figsizex</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">figsizey</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">show_titles</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">tight_layout</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">colorbar_width</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># in percent, standard is 5 or 10</span>
    <span class="n">hspace</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1">#standard is 0.4</span>
    <span class="c1"># Define Plot font sizes</span>
    <span class="n">font_size_default</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">font_size_axes_title</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">font_size_axes_label</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">font_size_tick_labels</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">font_size_legend</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">font_size_fig_title</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="c1">#definitions for color bar ranges:</span>
    <span class="c1"># using the same range for all channels is useful for comparison</span>
    <span class="c1"># make all height channels have the same range?</span>
    <span class="n">height_cbar_range</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">vmin_height</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vmax_height</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># make all amplitude channels have the same range?</span>
    <span class="n">amp_cbar_range</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">vmin_amp</span> <span class="o">=</span> <span class="kc">None</span><span class="c1">#1 # to make shure that the values will be initialized with the first plotting command</span>
    <span class="n">vmax_amp</span> <span class="o">=</span> <span class="kc">None</span><span class="c1">#-1</span>
    <span class="c1"># phase_cbar_range = True</span>
    <span class="c1"># plot the full 2pi range for the phase channels no matter what the actual data range is?</span>
    <span class="n">full_phase_range</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># this will overwrite the cbar</span>
    <span class="c1"># make all phase channels have the same range?</span>
    <span class="n">shared_phase_range</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># only used if full phase range is false</span>
    <span class="n">vmin_phase</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">vmax_phase</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">real_cbar_range</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">vlimit_real</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># vmin_real = None</span>
    <span class="c1"># vmax_real = None</span>
    <span class="c1"># show plot automatically? turn to false for gui programming</span>
    <span class="n">show_plot</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">autodelete_all_subplots</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># if true old subplots will be deleted on creation of new measurement</span></div>

    
<span class="c1"># new version is based on filehandler to do basic stuff and then a class for each different measurement type like snom/afm, approach curves, spectra etc.</span>
<div class="viewcode-block" id="FileHandler">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.FileHandler">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">FileHandler</span><span class="p">(</span><span class="n">PlotDefinitions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class handles the filetype and parameter type and all toplevel functionality.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">directory_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">PurePath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span><span class="p">)</span><span class="o">.</span><span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_savefolder</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_title</span> <span class="o">=</span> <span class="n">title</span> <span class="c1"># If a measurement_title is specified it will precede the automatically created title based on the channel dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logfile_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_logfile</span><span class="p">()</span>
        <span class="c1"># testing the new config file:</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_config</span><span class="p">()</span> <span class="c1"># load the config file</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_default_config</span><span class="p">()</span> <span class="c1"># create a default config file if not existing</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_file_type</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_savefolder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate savefolder if not already existing. Careful, has to be the same one as for the snom plotter gui app.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create parent folder in the user directory, both snom analysis and plotting cofig files will be saved there</span>
        <span class="n">parent_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">))</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;SNOM_Config&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">parent_folder</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">parent_folder</span><span class="p">)</span>
        <span class="c1"># create a save folder for the snom analysis config files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~&#39;</span><span class="p">))</span> <span class="o">/</span> <span class="n">parent_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;SNOM_Analysis&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span><span class="p">)</span>
        <span class="c1"># define the paths for the different files</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;all_subplots.p&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;plotting_parameters.json&#39;</span><span class="p">)</span> <span class="c1"># probably not a good idea to use the same folder as the snom plotter app</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_folder</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;config.ini&#39;</span><span class="p">)</span>

        
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_file_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># try to find the filetype automatically</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_find_filetype</span><span class="p">()</span> 

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_default_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function creates a default config file in case the script is run for the first time or the old config file is missing.</span>
<span class="sd">        This can also be called to reset the config file to default settings. But all manual changes will be lost.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
        <span class="c1"># careful with default, the content of default will be added to all other sections</span>
        <span class="c1"># config[&#39;DEFAULT&#39;] = {&#39;FILETYPE&#39;: &#39;FILETYPE2&#39;,</span>
        <span class="c1">#                     &#39;PARAMETERTYPE&#39;: &#39;PARAMETERTYPE6&#39;,</span>
        <span class="c1"># }</span>
        <span class="c1"># the default parameters will be taken from the default Filtype definition</span>
        <span class="c1"># todo remove this, this is just for internal testing</span>
        <span class="c1"># config[&#39;FILETYPES&#39;] = {</span>
        <span class="c1">#     &#39;FILETYPE1&#39;: &#39;standard_new&#39;,</span>
        <span class="c1">#     &#39;FILETYPE2&#39;: &#39;standard&#39;,</span>
        <span class="c1">#     &#39;FILETYPE3&#39;: &#39;aachen_gsf&#39;,</span>
        <span class="c1">#     &#39;FILETYPE4&#39;: &#39;aachen_ascii&#39;,</span>
        <span class="c1">#     &#39;FILETYPE5&#39;: &#39;neaspec_version_1_6_3359_1&#39;,</span>
        <span class="c1">#     &#39;FILETYPE6&#39;: &#39;comsol_gsf&#39;,</span>
        <span class="c1"># }</span>
        <span class="c1"># the order is important, as the script will try to find the filetype in the order specified here</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPES&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype1&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE1&gt;&#39;</span><span class="p">,</span> <span class="c1"># 1.10.9592.0 standard_new</span>
            <span class="s1">&#39;filetype2&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE2&gt;&#39;</span><span class="p">,</span> <span class="c1"># 1.8.5017.0 standard</span>
            <span class="s1">&#39;filetype3&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE3&gt;&#39;</span><span class="p">,</span> <span class="c1"># aachen gsf</span>
            <span class="s1">&#39;filetype4&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE4&gt;&#39;</span><span class="p">,</span> <span class="c1"># aachen ascii</span>
            <span class="s1">&#39;filetype5&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE5&gt;&#39;</span><span class="p">,</span> <span class="c1"># version 1.6.3359.1</span>
            <span class="s1">&#39;filetype6&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;FILETYPE6&gt;&#39;</span><span class="p">,</span> <span class="c1"># comsol</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;PARAMETERTYPES&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;PARAMETERTYPE1&#39;</span><span class="p">:</span> <span class="s1">&#39;html&#39;</span><span class="p">,</span>
            <span class="s1">&#39;PARAMETERTYPE2&#39;</span><span class="p">:</span> <span class="s1">&#39;txt&#39;</span><span class="p">,</span>
            <span class="s1">&#39;PARAMETERTYPE3&#39;</span><span class="p">:</span> <span class="s1">&#39;html_new&#39;</span><span class="p">,</span>
            <span class="s1">&#39;PARAMETERTYPE4&#39;</span><span class="p">:</span> <span class="s1">&#39;html_neaspec_version_1_6_3359_1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;PARAMETERTYPE5&#39;</span><span class="p">:</span> <span class="s1">&#39;comsol_txt&#39;</span><span class="p">,</span>
            <span class="s1">&#39;PARAMETERTYPE6&#39;</span><span class="p">:</span> <span class="s1">&#39;new_parameters_txt&#39;</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;TEST&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5P&#39;</span><span class="p">],</span>
                <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5A&#39;</span><span class="p">],</span>
                <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">],</span>
                <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">],</span>
                <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;Z C&#39;</span><span class="p">,</span>
                <span class="p">},</span>
            <span class="s1">&#39;parameterfile_definitions&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;splitter&#39;</span><span class="p">:</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span>
                <span class="s1">&#39;header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;#&#39;</span><span class="p">,</span>
                <span class="s1">&#39;tags&#39;</span><span class="p">:</span> <span class="p">{</span>
                    <span class="s1">&#39;scan_area&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan Area&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;center_pos&#39;</span><span class="p">:</span> <span class="s1">&#39;Center Pos&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;pixel_area&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel Area&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;pixel_scaling&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel Scaling&#39;</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;standard_new&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;new_parameters_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5A&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z C&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Z C&#39;</span><span class="p">,</span> <span class="s1">&#39;R-Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mechanical_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;M5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span> <span class="s1">&#39;O2P&#39;</span><span class="p">,</span> <span class="s1">&#39;Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;R-&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Re&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Im&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;M&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; raw&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;# &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;:&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.gsf&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="c1"># shift raw data to the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to reference enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the parameter file so they should match the file format</span>
                <span class="s1">&#39;SCAN&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan&#39;</span><span class="p">,</span> <span class="c1"># scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
                <span class="s1">&#39;PROJECT&#39;</span><span class="p">:</span> <span class="s1">&#39;Project&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DESCRIPTION&#39;</span><span class="p">:</span> <span class="s1">&#39;Description&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DATE&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="s1">&#39;Scanner Center Position (X, Y)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;Rotation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan Area (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel Area (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;AVERAGING&#39;</span><span class="p">:</span> <span class="s1">&#39;Averaging&#39;</span><span class="p">,</span>
                <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span> <span class="s1">&#39;Integration time&#39;</span><span class="p">,</span>
                <span class="s1">&#39;LASERSOURCE&#39;</span><span class="p">:</span> <span class="s1">&#39;Laser Source&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DETECTOR&#39;</span><span class="p">:</span> <span class="s1">&#39;Detector&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TARGETWAVELENGTH&#39;</span><span class="p">:</span> <span class="s1">&#39;Target Wavelength&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DEMODULATIONMODE&#39;</span><span class="p">:</span> <span class="s1">&#39;Demodulation Mode&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPAMPLITUTDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tapping Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Offset&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span> <span class="s1">&#39;Setpoint&#39;</span><span class="p">,</span>
                <span class="s1">&#39;REGULATOR&#39;</span><span class="p">:</span> <span class="s1">&#39;Regulator (P, I, D)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPPOTENTIAL&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Potential&#39;</span><span class="p">,</span>
                <span class="s1">&#39;M1ASCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;M1A Scaling&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Q-FACTOR&#39;</span><span class="p">:</span> <span class="s1">&#39;Q-Factor&#39;</span><span class="p">,</span>
                <span class="s1">&#39;VERSION&#39;</span><span class="p">:</span> <span class="s1">&#39;Version&#39;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;ChannelTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XRes&#39;</span><span class="p">,</span> <span class="s1">&#39;YRes&#39;</span><span class="p">],</span>
                <span class="s1">&#39;YINCOMPLETE&#39;</span><span class="p">:</span> <span class="s1">&#39;YResIncomplete&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;Neaspec_Angle&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XReal&#39;</span><span class="p">,</span> <span class="s1">&#39;YReal&#39;</span><span class="p">],</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XOffset&#39;</span><span class="p">,</span> <span class="s1">&#39;YOffset&#39;</span><span class="p">],</span>
                <span class="s1">&#39;XYUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;XYUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ZUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;ZUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;WAVENUMBERSCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;Neaspec_WavenumberScaling&#39;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;standard&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;new_parameters_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5A&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z C&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Z C&#39;</span><span class="p">,</span> <span class="s1">&#39;R-Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mechanical_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;M5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span> <span class="s1">&#39;O2P&#39;</span><span class="p">,</span> <span class="s1">&#39;Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;R-&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Re&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Im&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;M&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;# &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;:&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.gsf&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="c1"># shift raw data to the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to create enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the file so they should match the file format</span>
                <span class="c1"># &#39;SCAN&#39;: &#39;Scan&#39;, # scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
                <span class="s1">&#39;PROJECT&#39;</span><span class="p">:</span> <span class="s1">&#39;Project&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DESCRIPTION&#39;</span><span class="p">:</span> <span class="s1">&#39;Description&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DATE&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="s1">&#39;Scanner Center Position (X, Y)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;Rotation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan Area (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel Area (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;AVERAGING&#39;</span><span class="p">:</span> <span class="s1">&#39;Averaging&#39;</span><span class="p">,</span>
                <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span> <span class="s1">&#39;Integration time&#39;</span><span class="p">,</span>
                <span class="s1">&#39;LASERSOURCE&#39;</span><span class="p">:</span> <span class="s1">&#39;Laser Source&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;DETECTOR&#39;: &#39;Detector&#39;,</span>
                <span class="s1">&#39;TARGETWAVELENGTH&#39;</span><span class="p">:</span> <span class="s1">&#39;Target Wavelength&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DEMODULATIONMODE&#39;</span><span class="p">:</span> <span class="s1">&#39;Demodulation Mode&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPAMPLITUTDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tapping Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Offset&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span> <span class="s1">&#39;Setpoint&#39;</span><span class="p">,</span>
                <span class="s1">&#39;REGULATOR&#39;</span><span class="p">:</span> <span class="s1">&#39;Regulator (P, I, D)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPPOTENTIAL&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Potential&#39;</span><span class="p">,</span>
                <span class="s1">&#39;M1ASCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;M1A Scaling&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;Q-FACTOR&#39;: &#39;Q-Factor&#39;,</span>
                <span class="s1">&#39;VERSION&#39;</span><span class="p">:</span> <span class="s1">&#39;Version&#39;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;ChannelTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XRes&#39;</span><span class="p">,</span> <span class="s1">&#39;YRes&#39;</span><span class="p">],</span>
                <span class="s1">&#39;YINCOMPLETE&#39;</span><span class="p">:</span> <span class="s1">&#39;YResIncomplete&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;ROTATION&#39;: &#39;Neaspec_Angle&#39;,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XReal&#39;</span><span class="p">,</span> <span class="s1">&#39;YReal&#39;</span><span class="p">],</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XOffset&#39;</span><span class="p">,</span> <span class="s1">&#39;YOffset&#39;</span><span class="p">],</span>
                <span class="s1">&#39;XYUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;XYUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ZUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;ZUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;WAVENUMBERSCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;Neaspec_WavenumberScaling&#39;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;aachen_dumb&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;new_parameters_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-arg&#39;</span><span class="p">,</span> <span class="s1">&#39;O1-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-arg&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;O1-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O1-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-Re&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O1-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-Im&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MT-F-abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MT-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;MT-B-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2-F-abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2-F-arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O2-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;O2-F-arg&#39;</span><span class="p">,</span> <span class="s1">&#39;MT-F-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MT&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Re&gt;&#39;</span><span class="p">,</span><span class="c1">#not used</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Im&gt;&#39;</span><span class="p">,</span><span class="c1">#not used</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;M&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;-B-&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.parameters.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;:&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.dumb&gt;&#39;</span><span class="p">,</span>
            <span class="c1"># definitions for data loading:</span>
            <span class="c1"># todo the detector voltages should be handeled here, the following values are just placeholders</span>
            <span class="c1"># also gsf file reading for the gwyddion dump format is not implemented yet but ascii somewhat works</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="c1"># shift raw data to the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to create enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the file so they should match the file format</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scan_size_f (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;scan_size_s (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;scan_size_v (um)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;resolution_f (pt)&#39;</span><span class="p">,</span> <span class="s1">&#39;resolution_s (pt)&#39;</span><span class="p">,</span> <span class="s1">&#39;resolution_v (pt)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span> <span class="s1">&#39;pixel_time (ms)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;offset_x (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;offset_y (um)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;rotation_a (deg)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;probe_frequency (Hz)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_frequency (Hz)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;probe_amplitude (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_amplitude (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_offset (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span> <span class="s1">&#39;setpoint (V)&#39;</span><span class="p">,</span>
            <span class="p">},</span>


        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;aachen_ascii&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;new_parameters_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-arg&#39;</span><span class="p">,</span> <span class="s1">&#39;O1-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-arg&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-arg&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;O1-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-abs&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O1-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-Re&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-Re&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O2-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O3-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O4-F-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O1-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O2-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O3-B-Im&#39;</span><span class="p">,</span><span class="s1">&#39;O4-B-Im&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MT-F-abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;MT-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;MT-B-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2-F-abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2-F-arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O2-F-abs&#39;</span><span class="p">,</span> <span class="s1">&#39;O2-F-arg&#39;</span><span class="p">,</span> <span class="s1">&#39;MT-F-abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;MT&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Re&gt;&#39;</span><span class="p">,</span><span class="c1">#not used</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Im&gt;&#39;</span><span class="p">,</span><span class="c1">#not used</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;M&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;-B-&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.parameters.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;:&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.ascii&gt;&#39;</span><span class="p">,</span>
            <span class="c1"># definitions for data loading:</span>
            <span class="c1"># todo the detector voltages should be handeled here, the following values are just placeholders</span>
            <span class="c1"># also gsf file reading for the gwyddion dump format is not implemented yet but ascii somewhat works</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="c1"># shift raw data to the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to create enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the file so they should match the file format</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;scan_size_f (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;scan_size_s (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;scan_size_v (um)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;resolution_f (pt)&#39;</span><span class="p">,</span> <span class="s1">&#39;resolution_s (pt)&#39;</span><span class="p">,</span> <span class="s1">&#39;resolution_v (pt)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span> <span class="s1">&#39;pixel_time (ms)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;offset_x (um)&#39;</span><span class="p">,</span> <span class="s1">&#39;offset_y (um)&#39;</span><span class="p">],</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;rotation_a (deg)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;probe_frequency (Hz)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_frequency (Hz)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;probe_amplitude (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_amplitude (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span> <span class="s1">&#39;modulation_offset (V)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span> <span class="s1">&#39;setpoint (V)&#39;</span><span class="p">,</span>
            <span class="p">},</span>


        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE5&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;standard&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;new_parameters_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4P&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O2A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O3A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O4A&#39;</span><span class="p">,</span><span class="s1">&#39;R-O5A&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Re&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Re&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O1Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O2Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O3Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O4Im&#39;</span><span class="p">,</span> <span class="s1">&#39;R-O5Im&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z C&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Z C&#39;</span><span class="p">,</span> <span class="s1">&#39;R-Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mechanical_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;M5P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M0P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M1P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M2P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M3P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M4P&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5A&#39;</span><span class="p">,</span> <span class="s1">&#39;R-M5P&#39;</span><span class="p">],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O2P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span> <span class="s1">&#39;O2P&#39;</span><span class="p">,</span> <span class="s1">&#39;Z C&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;A&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;P&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;R-&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Re&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Im&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;O&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;M&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt; raw&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.gsf&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="c1"># shift raw data to the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to create enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the file so they should match the file format</span>
                <span class="c1"># &#39;SCAN&#39;: &#39;Scan&#39;, # scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
                <span class="s1">&#39;PROJECT&#39;</span><span class="p">:</span> <span class="s1">&#39;Project&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DESCRIPTION&#39;</span><span class="p">:</span> <span class="s1">&#39;Description&#39;</span><span class="p">,</span>
                <span class="s1">&#39;DATE&#39;</span><span class="p">:</span> <span class="s1">&#39;Date&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="s1">&#39;Scanner Center Position (X, Y)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="s1">&#39;Rotation&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan Size (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Resolution (X, Y, Z)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;AVERAGING&#39;</span><span class="p">:</span> <span class="s1">&#39;Number of samples&#39;</span><span class="p">,</span>
                <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel time&#39;</span><span class="p">,</span>
                <span class="s1">&#39;LASERSOURCE&#39;</span><span class="p">:</span> <span class="s1">&#39;Laser Source&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;DETECTOR&#39;: &#39;Detector&#39;,</span>
                <span class="s1">&#39;TARGETWAVELENGTH&#39;</span><span class="p">:</span> <span class="s1">&#39;Target Wavelength&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;DEMODULATIONMODE&#39;: &#39;Demodulation Mode&#39;,</span>
                <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPAMPLITUTDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Tapping Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Frequency&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Amplitude&#39;</span><span class="p">,</span>
                <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span> <span class="s1">&#39;Modulation Offset&#39;</span><span class="p">,</span>
                <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span> <span class="s1">&#39;Setpoint&#39;</span><span class="p">,</span>
                <span class="s1">&#39;REGULATOR&#39;</span><span class="p">:</span> <span class="s1">&#39;Regulator (P, I, D)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;TIPPOTENTIAL&#39;</span><span class="p">:</span> <span class="s1">&#39;Tip Potential&#39;</span><span class="p">,</span>
                <span class="s1">&#39;M1ASCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;M1A Scaling&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;Q-FACTOR&#39;: &#39;Q-Factor&#39;,</span>
                <span class="s1">&#39;VERSION&#39;</span><span class="p">:</span> <span class="s1">&#39;Version&#39;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;ChannelTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XRes&#39;</span><span class="p">,</span> <span class="s1">&#39;YRes&#39;</span><span class="p">],</span>
                <span class="c1"># &#39;YINCOMPLETE&#39;: &#39;YResIncomplete&#39;,</span>
                <span class="c1"># &#39;ROTATION&#39;: &#39;Neaspec_Angle&#39;,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XReal&#39;</span><span class="p">,</span> <span class="s1">&#39;YReal&#39;</span><span class="p">],</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XOffset&#39;</span><span class="p">,</span> <span class="s1">&#39;YOffset&#39;</span><span class="p">],</span>
                <span class="s1">&#39;XYUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;XYUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;ZUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;ZUnits&#39;</span><span class="p">,</span>
                <span class="s1">&#39;WAVENUMBERSCALING&#39;</span><span class="p">:</span> <span class="s1">&#39;Neaspec_WavenumberScaling&#39;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">config</span><span class="p">[</span><span class="s1">&#39;FILETYPE6&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;filetype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;comsol_gsf&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parametertype&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;comsol_txt&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;all_channels_default&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="s1">&#39;arg&#39;</span><span class="p">,</span> <span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="s1">&#39;imag&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">],</span> <span class="c1"># Z is not a standard channel, but the user might create it manually to show the simulation design</span>
            <span class="s1">&#39;phase_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;arg&#39;</span><span class="p">],</span>
            <span class="s1">&#39;amp_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;abs&#39;</span><span class="p">],</span>
            <span class="s1">&#39;real_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;real&#39;</span><span class="p">],</span>
            <span class="s1">&#39;imag_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;imag&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_channel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">],</span>
            <span class="s1">&#39;mechanical_channels&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;preview_channels&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="s1">&#39;arg&#39;</span><span class="p">],</span>
            <span class="s1">&#39;height_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;Z&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;amp_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;abs&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;arg&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;backwards_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;real_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;real&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;imag_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;imag&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;optical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;None&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;None&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_synccorrected&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_manipulated&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;_overlain&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_name&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.txt&gt;&#39;</span><span class="p">,</span> <span class="c1"># measurement_directory + parameters_name</span>
            <span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;# &gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;parameters_separator&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;:&gt;&#39;</span><span class="p">,</span>
            <span class="s1">&#39;file_ending&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;.gsf&gt;&#39;</span><span class="p">,</span>

            <span class="c1"># definitions for data loading:</span>
            <span class="s1">&#39;phase_offset_default&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume default data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># assume custom data is already in the interval [0, 2pi]</span>
            <span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="c1"># when in nm</span>
            <span class="s1">&#39;height_scaling_default&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="p">,</span> <span class="c1"># data is in m convert to nm</span>
            <span class="s1">&#39;MeasurementTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="c1"># carful the keys will be used to create enums, so they should be unique and uppercase, they also must be identical for all filetypes</span>
                <span class="c1"># the values are the tags in the file so they should match the file format</span>
                <span class="c1"># &#39;SCAN&#39;: &#39;Scan&#39;, # scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
                <span class="c1"># &#39;PROJECT&#39;: &#39;Project&#39;,</span>
                <span class="c1"># &#39;DESCRIPTION&#39;: &#39;Description&#39;,</span>
                <span class="c1"># &#39;DATE&#39;: &#39;Date&#39;,</span>
                <span class="c1"># &#39;SCANNERCENTERPOSITION&#39;: &#39;Scanner Center Position (X, Y)&#39;,</span>
                <span class="c1"># &#39;ROTATION&#39;: &#39;Rotation&#39;,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Scan Area (X, Y)&#39;</span><span class="p">,</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="s1">&#39;Pixel Area (X, Y)&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;AVERAGING&#39;: &#39;Number of samples&#39;,</span>
                <span class="c1"># &#39;INTEGRATIONTIME&#39;: &#39;Pixel Time&#39;,</span>
                <span class="c1"># &#39;LASERSOURCE&#39;: &#39;Laser Source&#39;,</span>
                <span class="c1"># &#39;DETECTOR&#39;: &#39;Detector&#39;,</span>
                <span class="c1"># &#39;TARGETWAVELENGTH&#39;: &#39;Target Wavelength&#39;,</span>
                <span class="c1"># &#39;DEMODULATIONMODE&#39;: &#39;Demodulation Mode&#39;,</span>
                <span class="c1"># &#39;TIPFREQUENCY&#39;: &#39;Tip Frequency&#39;,</span>
                <span class="c1"># &#39;TIPAMPLITUTDE&#39;: &#39;Tip Amplitude&#39;,</span>
                <span class="c1"># &#39;TAPPINGAMPLITUDE&#39;: &#39;Tapping Amplitude&#39;,</span>
                <span class="c1"># &#39;MODULATIONFREQUENCY&#39;: &#39;Modulation Frequency&#39;,</span>
                <span class="c1"># &#39;MODULATIONAMPLITUDE&#39;: &#39;Modulation Amplitude&#39;,</span>
                <span class="c1"># &#39;MODULATIONOFFSET&#39;: &#39;Modulation Offset&#39;,</span>
                <span class="c1"># &#39;SETPOINT&#39;: &#39;Setpoint&#39;,</span>
                <span class="c1"># &#39;REGULATOR&#39;: &#39;Regulator (P, I, D)&#39;,</span>
                <span class="c1"># &#39;TIPPOTENTIAL&#39;: &#39;Tip Potential&#39;,</span>
                <span class="c1"># &#39;M1ASCALING&#39;: &#39;M1A Scaling&#39;,</span>
                <span class="c1"># &#39;Q-FACTOR&#39;: &#39;Q-Factor&#39;,</span>
                <span class="s1">&#39;VERSION&#39;</span><span class="p">:</span> <span class="s1">&#39;Version&#39;</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="s1">&#39;ChannelTags&#39;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XRes&#39;</span><span class="p">,</span> <span class="s1">&#39;YRes&#39;</span><span class="p">],</span>
                <span class="c1"># &#39;YINCOMPLETE&#39;: &#39;YResIncomplete&#39;,</span>
                <span class="c1"># &#39;ROTATION&#39;: &#39;Neaspec_Angle&#39;,</span>
                <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XReal&#39;</span><span class="p">,</span> <span class="s1">&#39;YReal&#39;</span><span class="p">],</span>
                <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;XOffset&#39;</span><span class="p">,</span> <span class="s1">&#39;YOffset&#39;</span><span class="p">],</span>
                <span class="s1">&#39;XYUNIT&#39;</span><span class="p">:</span> <span class="s1">&#39;XYUnits&#39;</span><span class="p">,</span>
                <span class="c1"># &#39;ZUNIT&#39;: &#39;ZUnits&#39;,</span>
                <span class="c1"># &#39;WAVENUMBERSCALING&#39;: &#39;Neaspec_WavenumberScaling&#39;,</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
            <span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">config</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function loads the config file and returns the config object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">config</span> <span class="o">=</span> <span class="n">ConfigParser</span><span class="p">()</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_print_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function prints the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">section</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">option</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">section</span><span class="p">,</span><span class="w"> </span><span class="n">option</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_change_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">option</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function changes the config file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if value is a string add quotes</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;&lt;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&gt;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">option</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified section or option does not exist in the config file!&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The available options are: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">section</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>	
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The available sections are: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">sections</span><span class="p">())</span>
        <span class="c1"># update the config file        </span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">configfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">configfile</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_from_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">section</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function gets the value of an option in a section of the config file.</span>
<span class="sd">        If no option is specified the whole section is returned.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">section</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># set the section to the file type if it is not specified, but only if file_type is defined</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">section</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span>
            <span class="k">except</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Filetype unknown, please specify the section! (In _get_from_config)&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">section</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="n">section</span><span class="p">][</span><span class="n">option</span><span class="p">]</span>
            <span class="c1"># replace &lt; and &gt; with empty string if value is a string</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="c1"># convert string to list if it is a list</span>
                <span class="c1"># elif value[0] == &#39;[&#39;:</span>
                <span class="c1">#     value = ast.literal_eval(value)</span>
                <span class="c1"># # convert string to dictionary if it is a dictionary</span>
                <span class="c1"># elif value[0] == &#39;{&#39;:</span>
                <span class="c1">#     value = ast.literal_eval(value)</span>
                <span class="c1"># replace string with boolean if it is a boolean</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;True&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;False&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;None&#39;</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># try to convert string to float or int or list or dict</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">literal_eval</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>

            <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_print_MeasurementTags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function prints the measurement tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print the content of the measurement tags class</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All measurement tags: &#39;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_filetype</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">filetypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="s1">&#39;FILETYPES&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">filetypes</span><span class="p">:</span>
            <span class="n">filetype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s1">&#39;FILETYPES&#39;</span><span class="p">)</span>
            <span class="n">parameters_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;parameters_name&#39;</span><span class="p">,</span> <span class="n">filetype</span><span class="p">)</span>
            <span class="n">parameters_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">parameters_name</span><span class="p">)</span>
            <span class="c1"># try to create the measurement tag dict</span>
            <span class="n">succsess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_measurement_tag_dict</span><span class="p">(</span><span class="n">parameters_path</span><span class="p">,</span> <span class="n">filetype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">succsess</span><span class="p">:</span>
                <span class="c1"># the correct filetype has been found</span>
                <span class="c1"># print(f&#39;Filetype found: {filetype}&#39;)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">=</span> <span class="n">filetype</span>
                <span class="c1"># print(&#39;parameter dict was created successfully&#39;)                </span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># if no filetype was found return False</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No filetype was found!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
            
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_logfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># logfile_path = self.directory_name + &#39;/python_manipulation_log.txt&#39;</span>
        <span class="n">logfile_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="s1">&#39;python_manipulation_log.txt&#39;</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">logfile_path</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="c1"># the new logdata will be appended to the existing file</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">current_datetime</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">/%m/%Y %H:%M:%S&quot;</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">current_datetime</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;filename = &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">logfile_path</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_write_to_logfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">parameter</span><span class="p">):</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logfile_path</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">parameter_name</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">parameter</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
 
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_measurement_tag_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters_path</span><span class="p">:</span><span class="n">Path</span><span class="p">,</span> <span class="n">filetype</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function creates a dictionary containing the measurement tags. The tags are extracted from the parameters file.</span>
<span class="sd">        If the tag dict cannot be created the function will return False otherwise True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check if the file exists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">parameters_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">separator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;parameters_separator&#39;</span><span class="p">,</span> <span class="n">filetype</span><span class="p">)</span>
        <span class="n">header_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;parameters_header_indicator&#39;</span><span class="p">,</span> <span class="n">filetype</span><span class="p">)</span>
        <span class="n">MeasurementTags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;MeasurementTags&#39;</span><span class="p">,</span> <span class="n">filetype</span><span class="p">)</span>
        <span class="n">tags_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># if tags contains a list of values flatten the list</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tags_list</span><span class="p">):</span>
            <span class="n">tags_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">tags_list</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
                
        <span class="n">parameters_dict</span> <span class="o">=</span> <span class="n">convert_header_to_dict</span><span class="p">(</span><span class="n">parameters_path</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="n">separator</span><span class="p">,</span> <span class="n">header_indicator</span><span class="o">=</span><span class="n">header_indicator</span><span class="p">,</span> <span class="n">tags_list</span><span class="o">=</span><span class="n">tags_list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parameters_dict</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># now create the measurement tag dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span> <span class="o">=</span> <span class="p">{}</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        # SCAN = auto()   # scan type, afm, snom, approach curve, 2d/3d, PsHet...</span>
<span class="sd">        # PROJECT = auto()   </span>
<span class="sd">        # DESCRIPTION = auto()   </span>
<span class="sd">        # DATE = auto()   </span>
<span class="sd">        # SCANNERCENTERPOSITION = auto()   </span>
<span class="sd">        # ROTATION = auto()   </span>
<span class="sd">        # SCANAREA = auto()  </span>
<span class="sd">        # PIXELAREA = auto()   </span>
<span class="sd">        # AVERAGING = auto()   </span>
<span class="sd">        # INTEGRATIONTIME = auto()   </span>
<span class="sd">        # LASERSOURCE = auto()   </span>
<span class="sd">        # DETECTOR = auto()   </span>
<span class="sd">        # TARGETWAVELENGTH = auto()    </span>
<span class="sd">        # DEMODULATIONMODE = auto()   </span>
<span class="sd">        # TIPFREQUENCY = auto()   </span>
<span class="sd">        # TIPAMPLITUTDE = auto()   </span>
<span class="sd">        # TAPPINGAMPLITUDE = auto()   </span>
<span class="sd">        # MODULATIONFREQUENCY = auto()   </span>
<span class="sd">        # MODULATIONAMPLITUDE = auto()   </span>
<span class="sd">        # MODULATIONOFFSET = auto()   </span>
<span class="sd">        # SETPOINT = auto()   </span>
<span class="sd">        # REGULATOR = auto()   </span>
<span class="sd">        # TIPPOTENTIAL = auto()   </span>
<span class="sd">        # M1ASCALING = auto()  </span>
<span class="sd">        # QFACTOR = auto()   </span>
<span class="sd">        # VERSION = auto()</span>
<span class="sd">        # &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">is_list</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">is_list</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
                <span class="c1"># check if first value is a is_unit</span>
                <span class="k">try</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># sometimes only the is_unit is given</span>
                <span class="k">try</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">MeasurementTags</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">tag_key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="nb">list</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;SCAN&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCAN</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;PROJECT&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PROJECT</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;DESCRIPTION&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">DESCRIPTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;DATE&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">DATE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span> <span class="c1"># is_unit, x, y</span>
                <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span> <span class="c1"># is_unit, angle</span>
                <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span> <span class="c1"># is_unit, x, y, z</span>
                <span class="c1"># some files have only 2 values for the scan area with or without is_unit</span>
                <span class="c1"># check if first value is a is_unit</span>
                <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span> <span class="c1"># is_unit, x, y, z</span>
                <span class="c1"># print(&#39;PixelArea value: &#39;, value)</span>
                <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;AVERAGING&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">AVERAGING</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>  
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;INTEGRATIONTIME&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">INTEGRATIONTIME</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">INTEGRATIONTIME</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">INTEGRATIONTIME</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;LASERSOURCE&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">LASERSOURCE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;DETECTOR&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">DETECTOR</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;TARGETWAVELENGTH&#39;</span><span class="p">:</span> <span class="c1"># wavelength is usually not given...</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TARGETWAVELENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TARGETWAVELENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TARGETWAVELENGTH</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;DEMODULATIONMODE&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">DEMODULATIONMODE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;TIPFREQUENCY&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;TIPAMPLITUTDE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPAMPLITUTDE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPAMPLITUTDE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPAMPLITUTDE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;TAPPINGAMPLITUDE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TAPPINGAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TAPPINGAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TAPPINGAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;MODULATIONFREQUENCY&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONFREQUENCY</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;MODULATIONAMPLITUDE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONAMPLITUDE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;MODULATIONOFFSET&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">MODULATIONOFFSET</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;SETPOINT&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SETPOINT</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SETPOINT</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SETPOINT</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;REGULATOR&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">REGULATOR</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">REGULATOR</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">REGULATOR</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;TIPPOTENTIAL&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPPOTENTIAL</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPPOTENTIAL</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">TIPPOTENTIAL</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;M1ASCALING&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">M1ASCALING</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">M1ASCALING</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="k">else</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">M1ASCALING</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;QFACTOR&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">QFACTOR</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tag_key</span> <span class="o">==</span> <span class="s1">&#39;VERSION&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">VERSION</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># only used by synccorrection, every other function should use the channels tag dict version, as pixel resolution could vary</span>
        <span class="n">pixelarea</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="c1"># scanarea = self.measurement_tag_dict[MeasurementTags.SCANAREA]</span>
        <span class="n">scanarea</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pixelarea</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pixelarea</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XRes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">YRes</span> <span class="o">=</span> <span class="n">pixelarea</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixelarea</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1"># [unit, x, y, (z)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XReal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">YReal</span> <span class="o">=</span> <span class="n">scanarea</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scanarea</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XRes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">YRes</span> <span class="o">=</span> <span class="n">pixelarea</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pixelarea</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># [x, y]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">XReal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">YReal</span> <span class="o">=</span> <span class="n">scanarea</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scanarea</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># if everything went well return True</span>
        <span class="k">return</span> <span class="kc">True</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">:</span><span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function replaces the placeholders in the plotting parameters dictionary with the actual values. </span>
<span class="sd">        Afterwards it replaces the colormap placeholders with the actual colormaps.</span>

<span class="sd">        Args:</span>
<span class="sd">            dictionary (dict): plotting parameters dictionary</span>
<span class="sd">            placeholders (dict): dictionary containing the string definition of the placeholder and its value</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: the updated plotting parameters dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># colormaps = {&quot;&lt;SNOM_amplitude&gt;&quot;: SNOM_amplitude,</span>
        <span class="c1">#             &quot;&lt;SNOM_height&gt;&quot;: SNOM_height,</span>
        <span class="c1">#             &quot;&lt;SNOM_phase&gt;&quot;: SNOM_phase,</span>
        <span class="c1">#             &quot;&lt;SNOM_realpart&gt;&quot;: SNOM_realpart}</span>
        
        <span class="c1"># first iterate through all placeholders and replace them in the dictionary</span>
        <span class="k">for</span> <span class="n">placeholder</span> <span class="ow">in</span> <span class="n">placeholders</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">placeholders</span><span class="p">[</span><span class="n">placeholder</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">placeholder</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">placeholder</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="c1"># print(&#39;replaced channel!&#39;)</span>
        <span class="c1"># replace colormaps</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">colormap</span> <span class="ow">in</span> <span class="n">all_colormaps</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">colormap</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_colormaps</span><span class="p">[</span><span class="n">colormap</span><span class="p">]</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="n">dictionary</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_plotting_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This will load the plotting parameters dictionary from the plotting_parameters.json file. If the file does not exist, it will be created with default values.</span>
<span class="sd">        The dictionary contains definitions for the colormaps, the colormap labels and the titles of the subplots. It also contains placeholders, which can be replaced by the actual values.</span>
<span class="sd">        The user can change the values in the plotting_parameters.json file to customize the plotting.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: plotting parameters dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_default_plotting_parameters</span><span class="p">()</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plotting_parameters</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_default_plotting_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SNOM_amplitude&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">:</span> <span class="s2">&quot;Amplitude / a.u.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;amplitude_title&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phase_cmap&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SNOM_phase&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">:</span> <span class="s2">&quot;Phase / rad&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phase_title&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phase_positive_title&quot;</span><span class="p">:</span> <span class="s2">&quot;Positively corrected phase &lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;phase_negative_title&quot;</span><span class="p">:</span> <span class="s2">&quot;Negatively corrected phase &lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;height_cmap&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SNOM_height&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;height_cbar_label&quot;</span><span class="p">:</span> <span class="s2">&quot;Height / nm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;height_title&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real_cmap&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;SNOM_realpart&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real_cbar_label&quot;</span><span class="p">:</span> <span class="s2">&quot;E / a.u.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real_title_real&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;real_title_imag&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;channel&gt;&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fourier_cmap&quot;</span><span class="p">:</span> <span class="s2">&quot;viridis&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fourier_cbar_label&quot;</span><span class="p">:</span> <span class="s2">&quot;Intensity / a.u.&quot;</span><span class="p">,</span>
            <span class="s2">&quot;fourier_title&quot;</span><span class="p">:</span> <span class="s2">&quot;Fourier transform&quot;</span><span class="p">,</span>
            <span class="s2">&quot;gauss_blurred_title&quot;</span><span class="p">:</span> <span class="s2">&quot;Blurred &lt;channel&gt;&quot;</span>
        <span class="p">}</span>
        <span class="c1"># Todo: add more parameters to the dictionary</span>
        <span class="c1"># make a similar file for the snom plotter app and overwrite the defaults from the snom anlaysis package</span>
        <span class="c1"># make it possible to add mutliple sets of parameters, each for a different filetype</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        channel indicators</span>
<span class="sd">        channel labels</span>
<span class="sd">        channel prefixes</span>
<span class="sd">        channel suffixes</span>
<span class="sd">        file endings (.gsf, .txt, .ascii, ...)</span>
<span class="sd">        synccorrected channel indicator</span>
<span class="sd">        manipulated channel indicator</span>
<span class="sd">        filetype indicator? (standard, aachen, comsol, ...)</span>
<span class="sd">        parameters type indicator? (txt, html, gsf)</span>
<span class="sd">        add all plotting parameters</span>
<span class="sd">        enable/disable logfiles</span>
<span class="sd">        standard channels</span>
<span class="sd">        also add the default values for the loading of the data like:</span>
<span class="sd">            phaseoffset</span>
<span class="sd">            rounding_decimal (amp, phase, height, ...)</span>
<span class="sd">            scaling</span>
<span class="sd">        allow to add a list of custom channels which will be added to all_channels_custom</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_parameters_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
   
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">ChannelTags</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the value of the specified tag for the specified channel. If the tag is not found, it will return None.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (ChannelTags): tag name</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: tag value or values as a list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">]</span>
        <span class="c1"># check if a unit is part of the value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="c1"># if a unit is part of the value it must be in first place</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">MeasurementTags</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the value of the specified tag for the current measurement. If the tag is not found, it will return None.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (MeasurementTags): tag name</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: tag value or values as a list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="c1"># check if a unit is part of the value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="c1"># if a unit is part of the value it must be in first place</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_channel_tag_dict_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">ChannelTags</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the value of the specified tag for the specified channel. If the tag is not found, it will return None.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (ChannelTags): tag name</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: tag unit if there is one</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">]</span>
        <span class="c1"># check if a unit is part of the value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="c1"># if a unit is part of the value it must be in first place</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">MeasurementTags</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the value of the specified tag for the current measurement. If the tag is not found, it will return None.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (MeasurementTags): tag name</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: tag unit if there is one</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span>
        <span class="c1"># check if a unit is part of the value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="c1"># if a unit is part of the value it must be in first place</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">ChannelTags</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the value of the specified tag for the specified channel.</span>
<span class="sd">        It automatically tries to keep the unit of the value if there is one. </span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (ChannelTags): tag name</span>
<span class="sd">            value (list): tag values as a list, or single value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ckeck if value is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># check that no strings are in the list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the provided values is a string, use set_channel_tag_dict_unit to change the unit!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># try to get old unit</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_unit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="c1"># set the new values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if unit is provided</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># dont add the str value to the channel dict, if a unit should be changed use the set_channel_tag_dict_unit function</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Provided value is a string, use set_channel_tag_dict_unit to change the unit!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set new value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_measurement_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">MeasurementTags</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the value of the specified tag for the current measurement.</span>
<span class="sd">        It automatically tries to keep the unit of the value if there is one. </span>

<span class="sd">        Args:</span>
<span class="sd">            tag (MeasurementTags): tag name</span>
<span class="sd">            value (list): tag values as a list, or single value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># ckeck if value is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># check that no strings are in the list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;One of the provided values is a string, use set_channel_tag_dict_unit to change the unit!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># try to get old unit</span>
                <span class="n">unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_value</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="c1"># set the new values</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># check if unit is provided</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># dont add the str value to the channel dict, if a unit should be changed use the set_channel_tag_dict_unit function</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Provided value is a string, use set_channel_tag_dict_unit to change the unit!&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># set new value</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_channel_tag_dict_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">ChannelTags</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the unit of the specified tag for the specified channel.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>
<span class="sd">            tag (ChannelTags): tag name</span>
<span class="sd">            value (str): unit of the specified tag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if old unit exists</span>
        <span class="n">old_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_unit</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This filtype has no unit for the specified tag!</span><span class="se">\n</span><span class="s1">Setting the unit anayways...&#39;</span><span class="p">)</span>
            <span class="n">old_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span> <span class="c1"># shift the old values to the right</span>
            <span class="c1"># check if old values are in a list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="n">old_values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">old_values</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)][</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_measurement_tag_dict_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span><span class="n">MeasurementTags</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the unit of the specified tag for the current measurement.</span>

<span class="sd">        Args:</span>
<span class="sd">            tag (MeasurementTags): tag name</span>
<span class="sd">            value (str): unit of the specified tag</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if old unit exists</span>
        <span class="n">old_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_unit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;This filtype has no unit for the specified tag!</span><span class="se">\n</span><span class="s1">Setting the unit anayways...&#39;</span><span class="p">)</span>
            <span class="n">old_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span> <span class="c1"># shift the old values to the right</span>
            <span class="c1"># check if old values are in a list</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_values</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">+</span> <span class="n">old_values</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">,</span> <span class="n">old_values</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_tagval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function gets the value of the tag listed in the file header&quot;&quot;&quot;</span>
        <span class="n">content_array</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">tag_array</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tagval</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># if no tag val can be found return 0</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">content_array</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">:</span> <span class="c1"># its probably not part of the header anymore...</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="s1">&#39;=&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">element</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tag_pair</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="c1"># print(f&#39;tag_pair = {tag_pair}&#39;)</span>
                <span class="n">tag_name</span> <span class="o">=</span> <span class="n">tag_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="c1"># remove possible &#39; &#39; characters</span>
                <span class="n">tag_val</span> <span class="o">=</span> <span class="n">tag_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="c1"># remove possible &#39; &#39; characters</span>
                <span class="n">tag_array</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">tag_name</span><span class="p">,</span> <span class="n">tag_val</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tag_array</span><span class="p">)):</span>
            <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">try</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">tag_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">tag_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tag</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_unit</span><span class="p">:</span>
                    <span class="n">tagval</span> <span class="o">=</span> <span class="n">tag_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tagval</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tag_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">tagval</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_optomechanical_indicator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the optomechanical indicator of the channel and its index in the channel name.</span>
<span class="sd">        Meaning it tries to find out wether the cannel is an optical or mechanical channel.&quot;&quot;&quot;</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="n">indicator</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">indicator_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_indicator</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel</span><span class="p">)):</span>
                <span class="c1"># for char in channel:</span>
                <span class="k">if</span> <span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span><span class="p">:</span>
                    <span class="n">indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span>
                    <span class="n">indicator_index</span> <span class="o">=</span> <span class="n">i</span> <span class="c1"># return the first occurence of the indicator</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">channel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_indicator</span><span class="p">:</span>	
                    <span class="n">indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_indicator</span>
                    <span class="n">indicator_index</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">indicator_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># print(&#39;optomechanical indicator for this filetype is not yet implemented&#39;)</span>
        <span class="c1"># check that the channel is not a height channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">indicator</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">indicator_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">indicator</span><span class="p">,</span> <span class="n">indicator_index</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_amp_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the channel is an amplitude channel, False otherwise.&quot;&quot;&quot;</span>
        <span class="n">optomechanical_indicator</span><span class="p">,</span> <span class="n">indicator_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optomechanical_indicator</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optomechanical_indicator</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
            
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_phase_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the channel is a phase channel, False otherwise.&quot;&quot;&quot;</span>
        <span class="n">optomechanical_indicator</span><span class="p">,</span> <span class="n">indicator_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optomechanical_indicator</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optomechanical_indicator</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_complex_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the channel is a complex channel, False otherwise.&quot;&quot;&quot;</span>
        <span class="n">optomechanical_indicator</span><span class="p">,</span> <span class="n">indicator_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optomechanical_indicator</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optomechanical_indicator</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_height_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the channel is a height channel, False otherwise.&quot;&quot;&quot;</span>
        <span class="n">optomechanical_indicator</span><span class="p">,</span> <span class="n">indicator_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optomechanical_indicator</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optomechanical_indicator</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_channel_has_demod_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns True if the channel has a demodulation number, False otherwise.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: _description_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># only amplitude, phase, complex and mechanical (amp, phase) channels can have a demodulation number not the height channels</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_amp_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_phase_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_complex_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_height_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;unknown channel encountered in _channel_has_demod_num&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_demodulation_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the demodulation number of the channel.</span>
<span class="sd">        So far for all known filetypes the demodulation number is the number behind the optomechanical indicator (O or M) in the channel name.&quot;&quot;&quot;</span>
        <span class="n">optomechanical_indicator</span><span class="p">,</span> <span class="n">indicator_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_optomechanical_indicator</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="n">demodulation_num</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">indicator_index</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># if the index is None the channel is a height channel and has no demodulation number</span>
            <span class="n">demodulation_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">channel</span><span class="p">[</span><span class="n">indicator_index</span> <span class="o">+</span><span class="mi">1</span> <span class="p">:</span> <span class="n">indicator_index</span> <span class="o">+</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">demodulation_num</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_has_demod_num</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
            <span class="c1"># height channel for example has no demodulation number but should not cause an error</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;demodulation number could not be found&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">demodulation_num</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_measurement_channel_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># in the future these indicators should be read from external prameters file to make it easier for the user to add new filetypes with different indicators</span>
        <span class="c1"># the cannel prefix and suffix are characters surrounding the channel name in the filename, they will be used when loading and saving the data</span>
        <span class="c1"># filename = directory_name + channel_prefix + channel + channel_suffix + appendix + &#39;.gsf&#39; (or &#39;.txt&#39;) </span>
        <span class="c1"># appendix is just a standard appendix when saving to not overwrite the original files, can be changed by the user default is &#39;_manipulated&#39;</span>
        <span class="c1"># new approach based on cofigfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;amp_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;real_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;imag_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_channel&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;mechanical_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;preview_ampchannel&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;preview_phasechannel&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preview_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;preview_channels&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;amp_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;backwards_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;real_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;imag_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;optical_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_synccorrected_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_synccorrected_phase&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_manipulated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_overlain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;file_ending&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_offset_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_scaling_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">)</span>
        
        <span class="c1"># additional definitions independent of filetype:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span> <span class="o">=</span> <span class="s1">&#39;gauss&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_fourier_indicator</span> <span class="o">=</span> <span class="s1">&#39;fft&#39;</span>

        <span class="c1">#create also lists for the overlain channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlain_phase_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">+</span><span class="s1">&#39;_overlain&#39;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corrected_phase_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">+</span><span class="s1">&#39;_corrected&#39;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corrected_overlain_phase_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">+</span><span class="s1">&#39;_corrected_overlain&#39;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlain_amp_channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span><span class="o">+</span><span class="s1">&#39;_overlain&#39;</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlain_phase_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlain_amp_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrected_phase_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">corrected_overlain_phase_channels</span>
  
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_channel_tag_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function reads in the header of the gsf file for the specified channel and extracts the tag values. The tag values are stored in a dictionary for each channel.</span>
<span class="sd">        This tag dict is very similar to the measurement_tag_dict, but the measurement_tag_dict is only created on the basis of the parameter file.</span>
<span class="sd">        If individual channels have been modified this will only be stored in the channel_tag_dict.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel (str): channel name for which the tag values should be extracted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="c1"># create a list containing the tag dictionary for each channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">channel_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_custom</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> not found in default or custom channels!&#39;</span><span class="p">)</span>
                <span class="c1"># assume it is a custom channel and try loading anyways</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
                <span class="c1"># exit()</span>
            <span class="c1"># we want to read the non binary part of the datafile</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">==</span> <span class="s1">&#39;.gsf&#39;</span><span class="p">:</span>
                <span class="n">encod</span> <span class="o">=</span> <span class="s1">&#39;latin1&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">==</span> <span class="s1">&#39;.ascii&#39;</span><span class="p">:</span>
                <span class="n">encod</span> <span class="o">=</span> <span class="s1">&#39;latin1&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;file ending not supported&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">channel</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">),</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encod</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">content</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>


            <span class="n">ChannelTags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;ChannelTags&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">is_list</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">tag_value_found</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">is_list</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># so far each tag contains a maximum of 2 values</span>
                <span class="k">if</span> <span class="n">is_list</span><span class="p">:</span>
                    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">tag</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tagval</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span> 
                            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                            <span class="n">tag_value_found</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span> 
                            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                            <span class="n">tag_value_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tagval</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span> <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">else</span><span class="p">:</span> <span class="n">tag_value_found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># try to find out if the value is a number or a unit</span>
                    <span class="k">try</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span> <span class="n">is_unit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># check if tag value was found</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tag_value_found</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Could not find the tag value for </span><span class="si">{</span><span class="n">tag</span><span class="si">}</span><span class="s1"> in channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">. You should probably check the config file.&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;PIXELAREA&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;YINCOMPLETE&#39;</span><span class="p">:</span>
                    <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">YINCOMPLETE</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;SCANNERCENTERPOSITION&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;ROTATION&#39;</span><span class="p">:</span>
                    <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;SCANAREA&#39;</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
                    <span class="k">except</span><span class="p">:</span> <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;XYUNIT&#39;</span><span class="p">:</span>
                    <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">XYUNIT</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;ZUNIT&#39;</span><span class="p">:</span>
                    <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">ZUNIT</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;WAVENUMBERSCALING&#39;</span><span class="p">:</span>
                    <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">WAVENUMBERSCALING</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="c1"># add pixel scaling to the channel dict, initially this is always 1</span>
            <span class="n">channel_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_dict</span><span class="p">)</span></div>



<div class="viewcode-block" id="SnomMeasurement">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">SnomMeasurement</span><span class="p">(</span><span class="n">FileHandler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class opens a snom measurement and handels all the snom related functions.&quot;&quot;&quot;</span>
    <span class="n">all_subplots</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autoscale</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">directory_name</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_measurement_channel_indicators</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># the standard channels which will be used if no channels are specified</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># make sure to copy the list to avoid changing the original list     </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale</span> <span class="o">=</span> <span class="n">autoscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">autodelete_all_subplots</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delete_all_subplots</span><span class="p">()</span> <span class="c1"># automatically delete old subplots</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function initializes the data in memory. If no channels are specified the already existing data is used,</span>
<span class="sd">        which is created automatically in the instance init method. If channels are specified, the instance data is overwritten.</span>
<span class="sd">        Channels must be specified as a list of channels.&quot;&quot;&quot;</span>
        <span class="c1"># print(f&#39;initialising channels: {channels}&#39;)</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#none means the channels specified in the instance creation should be used</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
            <span class="c1"># update the channel tag dictionary, makes the program compatible with differrently sized datasets, like original data plus manipulated, eg. cut data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_channel_tag_dict</span><span class="p">()</span>
            <span class="c1"># self._Create_Channels_Tag_Dict()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
            <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># reset all the instance variables dependent on the data, but nor the ones responsible for plotting</span>
            <span class="c1"># self.scaling_factor = 1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoscale</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_pixels</span><span class="p">()</span>
            <span class="c1"># initialize instance variables:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># not shure if it&#39;s best to reset the mask...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upper_y_bound</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lower_y_bound</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">align_points</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y_shifts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span> <span class="o">=</span> <span class="p">[]</span>    

<div class="viewcode-block" id="SnomMeasurement.initialize_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.initialize_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will load the data from the specified channels and replace the ones in memory.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: a list containing the channels you want to initialize</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span></div>


<div class="viewcode-block" id="SnomMeasurement.add_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.add_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will add the specified channels to memory without changing the already existing ones.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list): Channels to add to memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">+=</span> <span class="n">channels</span>
        <span class="c1"># update the channel tag dictionary, makes the program compatible with differrently sized datasets, like original data plus manipulated, eg. cut data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_channel_tag_dict</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="n">all_data</span><span class="p">,</span> <span class="n">channels_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># reset all the instance variables dependent on the data, but nor the ones responsible for plotting</span>
        <span class="c1"># self.scaling_factor = 1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoscale</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quadratic_pixels</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_all_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load all subplots from memory (located under APPDATA/SNOM_Plotter/all_subplots.p).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_subplots_path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span> <span class="o">=</span> <span class="p">[]</span>
         
    <span class="k">def</span><span class="w"> </span><span class="nf">_export_all_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Export all subplots to memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_subplots_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">pkl</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_delete_all_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete the subplot memory. Should be done always if new measurement row is investigated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_subplots_path</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span> <span class="o">=</span> <span class="p">[]</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_scale_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function scales a given 2D Array, it thus creates &#39;scaling&#39;**2 subpixels per pixel.</span>
<span class="sd">        The scaled array is returned.&quot;&quot;&quot;</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="o">*</span><span class="n">scaling</span><span class="p">,</span> <span class="n">xres</span><span class="o">*</span><span class="n">scaling</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
            <span class="c1"># line = np.zeros((xres))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scaling</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scaling</span><span class="p">):</span>
                        <span class="c1"># scaled_dataset[h][i*scaling + k][j*scaling + l] = array[i][j]</span>
                        <span class="n">scaled_array</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="o">*</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">scaled_array</span>

<div class="viewcode-block" id="SnomMeasurement.scale_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.scale_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scaling</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function scales all the data in memory or the specified channels.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to scale. If not specified all channels in memory will be scaled. Defaults to None.</span>
<span class="sd">            scaling (int, optional): Defines scaling factor. Each pixel will be scaled to scaling**2 subpixels. Defaults to 4.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;scaling&#39;</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="n">scaling</span><span class="p">)</span>
                <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XReal</span><span class="o">*</span><span class="n">scaling</span><span class="p">,</span> <span class="n">YReal</span><span class="o">*</span><span class="n">scaling</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> is not in memory! Please initiate the channels you want to use first!&#39;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads all binary data of the specified channels and returns them in a list plus the dictionary with the channel information.</span>
<span class="sd">        Height data is automatically converted to nm. &quot;&quot;&quot;</span>

        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="c1"># check if channel is a default channel or something user made</span>
            <span class="c1"># if default use the standard naming convention</span>
            <span class="c1"># if user made dont use the &#39;_raw&#39; suffix</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_custom</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> not found in default or custom channels!&#39;</span><span class="p">)</span>
                <span class="c1"># assume it is a custom channel and try loading anyways</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
                <span class="c1"># exit()</span>
            <span class="c1"># check the readmode depending on the filetype</span>
            <span class="c1"># this also affects the way the data is read and processed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">==</span> <span class="s1">&#39;.gsf&#39;</span><span class="p">:</span>
                <span class="n">read_mode</span> <span class="o">=</span> <span class="s1">&#39;br&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">==</span> <span class="s1">&#39;.ascii&#39;</span><span class="p">:</span>
                <span class="n">read_mode</span> <span class="o">=</span> <span class="s1">&#39;r&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;file ending not supported&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">channel</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">),</span> <span class="n">read_mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">data</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">read_mode</span> <span class="o">==</span> <span class="s1">&#39;br&#39;</span><span class="p">:</span>
                <span class="n">binarydata</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">elif</span> <span class="n">read_mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                <span class="n">datalist</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">datalist</span> <span class="o">=</span> <span class="p">[</span><span class="n">element</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">datalist</span><span class="p">]</span>
                <span class="n">datalist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">datalist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="c1">#, dtype=np.float convert list to np.array and strings to float</span>
            
            <span class="c1"># get the resolution of the channel </span>
            <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="n">datasize</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">XRes</span><span class="o">*</span><span class="n">YRes</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">channel_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
            <span class="c1"># we knwo the resolution of the data from the header or parameter file</span>
            <span class="c1"># we use that to read the data from the end of the file until the end of the file minus the datasize</span>
            <span class="c1"># in this way we ignore the header and read only the data</span>
            <span class="k">if</span> <span class="n">read_mode</span> <span class="o">==</span> <span class="s1">&#39;br&#39;</span><span class="p">:</span>
                <span class="n">reduced_binarydata</span><span class="o">=</span><span class="n">binarydata</span><span class="p">[</span><span class="o">-</span><span class="n">datasize</span><span class="p">:]</span>

            <span class="c1"># depending on the channel type set the scaling, phase_offset and rounding_decimal</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># default scaling, not every channel needs scaling</span>
            <span class="n">phase_offset</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># default phase offset, not every channel needs a phase offset</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_amp_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_default</span>
                <span class="k">elif</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_custom</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_height_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                    <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_default</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_default</span>
                <span class="k">elif</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
                    <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_custom</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_custom</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_phase_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                    <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_default</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_default</span>
                <span class="k">elif</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
                    <span class="n">phase_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_custom</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_custom</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_complex_channel</span><span class="p">(</span><span class="n">channel</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_default</span>
                <span class="k">elif</span> <span class="n">channel_type</span> <span class="o">==</span> <span class="s1">&#39;custom&#39;</span><span class="p">:</span>
                    <span class="n">rounding_decimal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_custom</span>
            <span class="c1"># now read the data and apply the scaling, phase offset and rounding</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">read_mode</span> <span class="o">==</span> <span class="s1">&#39;br&#39;</span><span class="p">:</span>
                        <span class="n">pixval</span><span class="o">=</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span><span class="n">reduced_binarydata</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">XRes</span><span class="o">+</span><span class="n">x</span><span class="p">):</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">*</span><span class="n">XRes</span><span class="o">+</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)])[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">channel_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">pixval</span><span class="o">*</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">phase_offset</span><span class="p">,</span> <span class="n">rounding_decimal</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">read_mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
                        <span class="n">datalist</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">datalist</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">scaling</span> <span class="o">+</span> <span class="n">phase_offset</span><span class="p">,</span> <span class="n">rounding_decimal</span><span class="p">)</span>
            
            <span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_data</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="c1"># data_dict currently is just a list of the channels, this list is not equivalent to self.channels as the data_dict</span>
        <span class="c1"># or later self.channels_label contains the names of the channels which are used as the plot title, they will change depending on the functions applied, eg. &#39;channel_blurred&#39; or channel_manipulated&#39;...</span>
        <span class="c1"># but self.channels will always contain the original channel name as this is used for internal referencing</span>
        <span class="k">return</span> <span class="n">all_data</span><span class="p">,</span> <span class="n">data_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_data_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loads all binary data of the specified channels and returns them in a list plus the dictionary for access&quot;&quot;&quot;</span>
        <span class="c1">#create a list containing all the lists of the individual channels</span>
        <span class="n">all_binary_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#safe the information about which channel is which list in a dictionary</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
            <span class="c1"># f=open(f&quot;{self.directory_name}/{self.filename} {channels[i]}.gsf&quot;,&quot;br&quot;)</span>
            <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">.gsf&#39;</span><span class="p">),</span><span class="s2">&quot;br&quot;</span><span class="p">)</span>
            <span class="n">binarydata</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">all_binary_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">binarydata</span><span class="p">)</span>
            <span class="n">data_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">all_binary_data</span><span class="p">,</span> <span class="n">data_dict</span>

<div class="viewcode-block" id="SnomMeasurement.set_min_to_zero">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.set_min_to_zero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_min_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function sets the min value of the specified channels to zero.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to set min value to zero. If not specified this will apply to all height channels in memory. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;set_min_to_zero&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
                <span class="n">flattened_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">data_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">flattened_data</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">data_min</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;At least one of the specified channels is not in memory! You probably should initialize the channels first.&#39;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_plotting_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="c1"># import plotting_parameters.json, here the user can tweek some options for the plotting, like automatic titles and colormap choices</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_parameters</span><span class="p">()</span>

        <span class="c1"># update the placeholders in the dictionary</span>
        <span class="c1"># the dictionary contains certain placeholders, which are now being replaced with the actual values</span>
        <span class="c1"># until now only the channel placeholder is used but more could be added</span>
        <span class="c1"># placeholders are indicated by the &#39;&lt;&#39; and &#39;&gt;&#39; characters</span>
        <span class="c1"># this step insures, that for example the title contains the correct channel name</span>
        <span class="n">placeholders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&lt;channel&gt;&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="n">plotting_parameters</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cmap&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;positive&#39;</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_positive_title&quot;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s1">&#39;negative&#39;</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_negative_title&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_title&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;height_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;height_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;height_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cbar_label&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_title_real&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_title_imag&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_fourier_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;fourier_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;fourier_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span>  <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;fourier_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;gauss_blurred_title&quot;</span><span class="p">]</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;channel: &#39;</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;self.amp_indicator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;self.phase_indicator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;self.height_indicator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;self.real_indicator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;self.imag_indicator: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In _add_subplot(), encountered unknown channel&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">title</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_add_subplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">scalebar</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds the specified data to the list of subplots. The list of subplots contains the data, the colormap,</span>
<span class="sd">        the colormap label and a title, which are generated from the channel information. The same array is also returned,</span>
<span class="sd">        so it can also be iterated by an other function to only plot the data of interest.&quot;&quot;&quot;</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_values</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="c1"># subplots.append([data, cmap, label, title])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_title</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_title</span> <span class="o">+</span> <span class="n">title</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        if scalebar != None:</span>
<span class="sd">            self.all_subplots.append([np.copy(data), cmap, label, title, scalebar])</span>
<span class="sd">            return [data, cmap, label, title, scalebar]</span>
<span class="sd">        else:</span>
<span class="sd">            self.all_subplots.append([np.copy(data), cmap, label, title])</span>
<span class="sd">            return [data, cmap, label, title]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">supplot</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;data&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">cmap</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="n">label</span><span class="p">,</span> <span class="s1">&#39;title&#39;</span><span class="p">:</span> <span class="n">title</span><span class="p">,</span> <span class="s1">&#39;scalebar&#39;</span><span class="p">:</span> <span class="n">scalebar</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_all_subplots</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">supplot</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_all_subplots</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">supplot</span>
    
<div class="viewcode-block" id="SnomMeasurement.remove_subplots">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.remove_subplots">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_array</span><span class="p">:</span><span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function removes the specified subplot from the memory.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            index_array [list]: The indices of the subplots to remove from the plot list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#sort the index array in descending order and delete the corresponding plots from the memory</span>
        <span class="n">index_array</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_all_subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_array</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_all_subplots</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.remove_last_subplots">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.remove_last_subplots">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_last_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">times</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function removes the last added subplots from the memory.</span>
<span class="sd">        Times specifies how often the last subplot should be removed.</span>
<span class="sd">        Times=1 means only the last, times=2 means the two last, ...</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            times [int]: how many subplots should be removed from the end of the list?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_all_subplots</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">times</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_all_subplots</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subplots</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function plots the subplots. The plots are created in a grid, by default the grid is optimized for 3 by 3. The layout changes dependent on the number of subplots</span>
<span class="sd">        of subplots and also the dimensions. Wider subplots are prefferably created vertically, otherwise they are plotted horizontally. Probably subject to future changes...&quot;&quot;&quot;</span>
        <span class="n">number_of_axis</span> <span class="o">=</span> <span class="mi">9</span>
        <span class="n">number_of_subplots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subplots</span><span class="p">)</span>
        <span class="c1"># print(&#39;Number of subplots: {}&#39;.format(number_of_subplots))</span>
        <span class="c1">#specify the way the subplots are organized</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">number_of_subplots</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">number_of_axis</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span>
        <span class="c1"># set the plotting font sizes:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;font&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_default</span><span class="p">)</span>          <span class="c1"># controls default text sizes</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">titlesize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_axes_title</span><span class="p">)</span>     <span class="c1"># fontsize of the axes title</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;axes&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_axes_label</span><span class="p">)</span>    <span class="c1"># fontsize of the x and y labels</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;xtick&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_tick_labels</span><span class="p">)</span>    <span class="c1"># fontsize of the tick labels</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;ytick&#39;</span><span class="p">,</span> <span class="n">labelsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_tick_labels</span><span class="p">)</span>    <span class="c1"># fontsize of the tick labels</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;legend&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_legend</span><span class="p">)</span>    <span class="c1"># legend fontsize</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rc</span><span class="p">(</span><span class="s1">&#39;figure&#39;</span><span class="p">,</span> <span class="n">titlesize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">font_size_fig_title</span><span class="p">)</span>  <span class="c1"># fontsize of the figure title</span>

        <span class="k">if</span> <span class="n">nrows</span> <span class="o">&gt;=</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">number_of_axis</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="n">number_of_subplots</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of subplots must be lager than 0!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">changed_orientation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">number_of_subplots</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">changed_orientation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
        <span class="c1"># calculate the ratio (x/y) of the data, if the ratio is larger than 1 the images are wider than high,</span>
        <span class="c1"># and they will prefferably be positiond vertically instead of horizontally</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">number_of_subplots</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">number_of_subplots</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span> <span class="ow">and</span> <span class="n">ratio</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="n">number_of_subplots</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">changed_orientation</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1">#create the figure with subplots</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>    
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizey</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figwidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizex</span><span class="p">)</span> 
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#start the plotting process</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">number_of_subplots</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ncols</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">ncols</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nrows</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">nrows</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="n">changed_orientation</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="s1">&#39;title&#39;</span><span class="p">]</span>
                    <span class="n">scalebar</span> <span class="o">=</span> <span class="n">subplots</span><span class="p">[</span><span class="n">counter</span><span class="p">][</span><span class="s1">&#39;scalebar&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">scalebar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dx</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">scalebar_label</span><span class="p">,</span> <span class="n">length_fraction</span><span class="p">,</span> <span class="n">height_fraction</span><span class="p">,</span> <span class="n">width_fraction</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">border_pad</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">frameon</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">box_color</span><span class="p">,</span> <span class="n">box_alpha</span><span class="p">,</span> <span class="n">scale_loc</span><span class="p">,</span> <span class="n">label_loc</span><span class="p">,</span> <span class="n">font_properties</span><span class="p">,</span> <span class="n">label_formatter</span><span class="p">,</span> <span class="n">scale_formatter</span><span class="p">,</span> <span class="n">fixed_value</span><span class="p">,</span> <span class="n">fixed_units</span><span class="p">,</span> <span class="n">animated</span><span class="p">,</span> <span class="n">rotation</span> <span class="o">=</span> <span class="n">scalebar</span>
                        <span class="n">scalebar</span> <span class="o">=</span> <span class="n">ScaleBar</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">scalebar_label</span><span class="p">,</span> <span class="n">length_fraction</span><span class="p">,</span> <span class="n">height_fraction</span><span class="p">,</span> <span class="n">width_fraction</span><span class="p">,</span>
                            <span class="n">location</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">border_pad</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">frameon</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">box_color</span><span class="p">,</span> <span class="n">box_alpha</span><span class="p">,</span> <span class="n">scale_loc</span><span class="p">,</span>
                            <span class="n">label_loc</span><span class="p">,</span> <span class="n">font_properties</span><span class="p">,</span> <span class="n">label_formatter</span><span class="p">,</span> <span class="n">scale_formatter</span><span class="p">,</span> <span class="n">fixed_value</span><span class="p">,</span> <span class="n">fixed_units</span><span class="p">,</span> <span class="n">animated</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span> 
                        <span class="n">axis</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">scalebar</span><span class="p">)</span>

                    <span class="c1">#center the colorscale for real data around 0</span>
                    <span class="c1"># get minima and maxima from data:</span>
                    <span class="n">flattened_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="n">min_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">flattened_data</span><span class="p">)</span>
                    <span class="n">max_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">flattened_data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">title</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span> <span class="ow">in</span> <span class="n">title</span><span class="p">:</span> <span class="c1"># for real part or imaginary part data</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span> <span class="o">==</span> <span class="s1">&#39;FILETYPE6&#39;</span><span class="p">:</span>
                            <span class="n">data</span> <span class="o">=</span> <span class="n">Set_nan_to_zero</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="c1">#comsol data can contain nan values which are problematic for min and max</span>
                        <span class="n">data_limit</span> <span class="o">=</span> <span class="n">Get_Largest_Abs</span><span class="p">(</span><span class="n">min_data</span><span class="p">,</span> <span class="n">max_data</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span> <span class="o">=</span> <span class="n">data_limit</span>
                        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">real_cbar_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span> <span class="o">&lt;</span> <span class="n">data_limit</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span> <span class="o">=</span> <span class="n">data_limit</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vlimit_real</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">data_limit</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">data_limit</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">cmap</span> <span class="o">==</span> <span class="n">SNOM_phase</span> <span class="ow">and</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">full_phase_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># for phase data</span>
                            <span class="n">vmin</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">vmax</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">cmap</span> <span class="o">==</span> <span class="n">SNOM_phase</span> <span class="ow">and</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">full_phase_range</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span> <span class="o">=</span> <span class="n">min_data</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">shared_phase_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span> <span class="o">&gt;</span> <span class="n">min_data</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span> <span class="o">=</span> <span class="n">min_data</span>
                                <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span> <span class="o">&lt;</span> <span class="n">max_data</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span> <span class="o">=</span> <span class="n">min_data</span>
                                <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_phase</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_phase</span><span class="p">)</span>
                            
                        <span class="k">elif</span> <span class="n">cmap</span> <span class="o">==</span> <span class="n">SNOM_amplitude</span> <span class="ow">and</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">amp_cbar_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_amp</span> <span class="o">=</span> <span class="n">min_data</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_amp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_amp</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="k">if</span> <span class="n">min_data</span> <span class="o">&lt;</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_amp</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_amp</span> <span class="o">=</span> <span class="n">min_data</span> <span class="c1"># update the min and max values in PlotDefinitions if new values are outside of range</span>
                            <span class="k">if</span> <span class="n">max_data</span> <span class="o">&gt;</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_amp</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_amp</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="n">vmin</span> <span class="o">=</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_amp</span>
                            <span class="n">vmax</span> <span class="o">=</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_amp</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">cmap</span> <span class="o">==</span> <span class="n">SNOM_height</span> <span class="ow">and</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">height_cbar_range</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_height</span> <span class="o">=</span> <span class="n">min_data</span> <span class="c1"># initialize for the first time</span>
                            <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_height</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_height</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="k">if</span> <span class="n">min_data</span> <span class="o">&lt;</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_height</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_height</span> <span class="o">=</span> <span class="n">min_data</span> <span class="c1"># update the min and max values in PlotDefinitions if new values are outside of range</span>
                            <span class="k">if</span> <span class="n">max_data</span> <span class="o">&gt;</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_height</span><span class="p">:</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_height</span> <span class="o">=</span> <span class="n">max_data</span>
                            <span class="n">vmin</span> <span class="o">=</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmin_height</span>
                            <span class="n">vmax</span> <span class="o">=</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">vmax_height</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># print(&#39;not plotting full range phase&#39;)</span>
                            <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
                    
                    <span class="c1"># legacy method to draw white pixels around masked areas, currently out of service because </span>
                    <span class="c1"># the mask is not stored in the plot variable but for the whole measurement.</span>
                    <span class="c1"># repeated calls of the measurement instance would lead to problems</span>
<span class="w">                    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                    if (cmap == SNOM_height) and (&#39;_masked&#39; in title) and (&#39;_reduced&#39; not in title):</span>
<span class="sd">                        # create a white border around the masked area, but show the full unmasked height data</span>
<span class="sd">                        border_width = 1</span>
<span class="sd">                        yres = len(data)</span>
<span class="sd">                        xres = len(data[0])</span>
<span class="sd">                        white_pixels = np.zeros((yres, xres))</span>
<span class="sd">                        for y in range(border_width, yres - border_width):</span>
<span class="sd">                            for x in range(border_width, xres - border_width):</span>
<span class="sd">                                mean = self._get_mean_value(self.mask_array, x, y, border_width)</span>
<span class="sd">                                if (self.mask_array[y][x] == 0) and (0 &lt; mean) and (mean &lt; 1):</span>
<span class="sd">                                    white_pixels[y, x] = 100</span>
<span class="sd">                        # The idea is to plot a second pcolormesh on the same axis as the height data</span>
<span class="sd">                        # Only the pixels with a nonzero value are displayed, all other are set to zero opacity (alpha value)</span>
<span class="sd">                        ncolors = 2</span>
<span class="sd">                        color_array = plt.get_cmap(&#39;Greys&#39;)(range(ncolors))</span>

<span class="sd">                        # change alpha values</span>
<span class="sd">                        color_array[:,-1] = np.linspace(0.0,1.0,ncolors)</span>

<span class="sd">                        # create a colormap object</span>
<span class="sd">                        map_object = LinearSegmentedColormap.from_list(name=&#39;rainbow_alpha&#39;,colors=color_array)</span>

<span class="sd">                        # register this new colormap with matplotlib</span>
<span class="sd">                        try:</span>
<span class="sd">                            plt.register_cmap(cmap=map_object)</span>
<span class="sd">                        except: pass</span>
<span class="sd">                        axis.pcolormesh(white_pixels, cmap=&#39;rainbow_alpha&#39;)</span>
<span class="sd">                    &#39;&#39;&#39;</span>
                    
                    <span class="c1"># invert y axis to fit to the scanning procedure which starts in the top left corner</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
                    <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># size is the size of colorbar relative to original axis, 100% means same size, 10% means 10% of original</span>
                    <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
                    <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">show_titles</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
                    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1">#turn off all unneeded axes</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">number_of_axis</span><span class="p">))):</span>
                <span class="k">if</span>  <span class="n">counter</span> <span class="o">&gt;=</span> <span class="n">number_of_subplots</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">changed_orientation</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">number_of_subplots</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span> 
                    <span class="n">axis</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>
                <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">hspace</span><span class="o">=</span><span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">hspace</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tight_layout</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    
<div class="viewcode-block" id="SnomMeasurement.switch_supplots">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.switch_supplots">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">switch_supplots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_id</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second_id</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function changes the position of the subplots.</span>
<span class="sd">        The first and second id corresponds to the positions of the two subplots which should be switched.</span>
<span class="sd">        This function will be repea you are satisfied.</span>

<span class="sd">        Args:</span>
<span class="sd">            first_id [int]: the first id of the two subplots which should be switched</span>
<span class="sd">            second_id [int]: the second id of the two subplots which should be switched</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">first_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">second_id</span> <span class="o">==</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">first_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Please enter the id of the first image: &#39;</span><span class="p">))</span>
            <span class="n">second_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Please enter the id of the second image: &#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_all_subplots</span><span class="p">()</span>
        <span class="n">first_subplot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">[</span><span class="n">first_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">[</span><span class="n">first_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">[</span><span class="n">second_id</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">[</span><span class="n">second_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_subplot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_export_all_subplots</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display_all_subplots</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you happy with the new positioning?&#39;</span><span class="p">)</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to change the order again?&#39;</span><span class="p">)</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">switch_supplots</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_display_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">channels</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add all data contained in dataset as subplots to one figure.</span>
<span class="sd">        The data has to be shaped beforehand!</span>
<span class="sd">        channels should contain the information which channel is stored at which position in the dataset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">subplots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
            <span class="n">scalebar</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">scalebar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_subplot</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">scalebar</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_subplots</span><span class="p">(</span><span class="n">subplots</span><span class="p">)</span>

<div class="viewcode-block" id="SnomMeasurement.display_all_subplots">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_all_subplots">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_all_subplots</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function displays all the subplots which have been created until this point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_all_subplots</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_subplots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_subplots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.display_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="c1">#, show_plot:bool=True</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function displays the channels in memory or the specified ones.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to display. If not specified all channels from memory will be plotted. Defaults to None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span>
            <span class="n">plot_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">plot_channels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                    <span class="n">dataset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>
                    <span class="n">plot_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span> 
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> is not in memory! Please initiate the channels you want to display first!&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_display_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">plot_channels</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.display_overlay">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_overlay">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_overlay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel1</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channel2</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function displays an overlay of two channels. The first channel is displayed in full color, the second channel is displayed width a specified alpha.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the colormaps</span>
        <span class="n">cmap1</span><span class="p">,</span> <span class="n">label1</span><span class="p">,</span> <span class="n">title1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_values</span><span class="p">(</span><span class="n">channel1</span><span class="p">)</span>
        <span class="n">cmap2</span><span class="p">,</span> <span class="n">label2</span><span class="p">,</span> <span class="n">title2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_values</span><span class="p">(</span><span class="n">channel2</span><span class="p">)</span>
        <span class="c1"># get the data</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel1</span><span class="p">)]</span>
        <span class="n">data2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel2</span><span class="p">)]</span>
        <span class="c1"># create the figure</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizey</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figwidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizex</span><span class="p">)</span>
        <span class="c1"># plot the data</span>
        <span class="n">img1</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap1</span><span class="p">)</span>
        <span class="n">img2</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">)</span>
        <span class="c1"># add the colorbar</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="c1"># invert y axis to fit to the scanning procedure which starts in the top left corner</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="c1"># add the title</span>
        <span class="c1"># ax.set_title(title)</span>
        <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_gauss_blurr_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies a gaussian blurr to the specified array, with a specified sigma. The blurred data is returned as a list.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>

<div class="viewcode-block" id="SnomMeasurement.gauss_filter_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.gauss_filter_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gauss_filter_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will gauss filter the specified channels. If no channels are specified, the ones in memory will be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to blurr, if not specified all channels will be blurred. Should not be used for phase. Defaults to None.</span>
<span class="sd">            sigma (int, optional): The &#39;width&#39; of the gauss blurr in pixels, you should scale the data before blurring. Defaults to 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;gaussian_filter_sigma&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        
        <span class="c1"># start the blurring:</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">channel_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="c1"># check pixel scaling from channel tag dict for each channel</span>
                <span class="n">pixel_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pixel_scaling</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The data in channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> is not yet scaled! Do you want to scale the data?&#39;</span><span class="p">)</span>
                        <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">([</span><span class="n">channel</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_index</span><span class="p">],</span> <span class="n">sigma</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channel_index</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> is not in memory! Please initiate the channels you want to use first!&#39;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_find_gauss_compatible_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function goes through all channels in memory and tries to find compatible pairs of amplitude and phase channels.</span>
<span class="sd">        The function returns a list of lists, where each sublist contains the indices of the amplitude and phase channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">channel_pairs</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># list of lists, where each sublist contains the indices of the amplitude and phase channel relative to the self.channels list</span>
        <span class="n">phase_channels</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># sort the phase channels in a separate list</span>
        <span class="n">amp_channels</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># sort the amplitude channels in a separate list e.g. [[demod, channel_index, channel_name]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)):</span>
            <span class="n">demod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_demodulation_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_amp_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">amp_channels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">demod</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_phase_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">phase_channels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">demod</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># now try to find a partner for each phase channel, if there are amp channels without a partner they will be blurred ignoring the phase</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phase_channels</span><span class="p">)):</span>
            <span class="n">possible_amp_partners</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">amp_channels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">amp_channels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># check if the demodulation number is the same</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">amp_channels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span> <span class="c1"># check if the data shape is the same</span>
                        <span class="n">possible_amp_partners</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">amp_channels</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_amp_partners</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">channel_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">possible_amp_partners</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_amp_partners</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found more than one possible amplitude channel for phase channel </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please specify the correct one! This channel will be ignored for now.&#39;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">channel_pairs</span>

<div class="viewcode-block" id="SnomMeasurement.gauss_filter_channels_complex">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.gauss_filter_channels_complex">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gauss_filter_channels_complex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scaling</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This fucton gauss filters the specified channels. If no channels are specified, all channels in memory will be used.</span>
<span class="sd">        The function is designed to work with complex data, where amplitude and phase are stored in separate channels.</span>
<span class="sd">        It will also blur heiht, real part and imaginary part channels and amplitude channels without phase partner and phase channels without amplitude partner if you want to.</span>
<span class="sd">        If the data is not scaled already the function will do it automatically, the default scaling factor is 4, works good with sigma=2.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels to blurr, must contain amplitude and phase of same channels.</span>
<span class="sd">            scaling [int]: the scaling factor used for scaling the data, default is 4</span>
<span class="sd">            sigma [int]: the sigma used for blurring the data, bigger sigma means bigger blurr radius</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;gaussian_filter_complex_sigma&#39;</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> is not in memory! Please initiate the channels you want to use first!&#39;</span><span class="p">)</span>

        <span class="c1"># get pairs of amplitude and phase channels</span>
        <span class="n">channel_pairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_gauss_compatible_channels</span><span class="p">()</span>
        <span class="c1"># make a list of the remaining channels</span>
        <span class="n">remaining_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">channel_pairs</span><span class="p">]</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">channel_pairs</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_phase_channel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="c1"># ignore phase channels</span>
                    <span class="n">remaining_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Channel </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> is a phase channel and does not have a compatible amplitude channel!&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;For phase data without amplitude please use the gauss_filter_channels() function!&#39;</span><span class="p">)</span>
                    <span class="c1"># get user input if the phase channel should be blurred without amplitude, might be useful in some cases when the phase is flat</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to blur this channel without amplitude anyways?&#39;</span><span class="p">)</span>
                    <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">remaining_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># check if the data is scaled, if not scale it</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_pairs</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># scale the data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">scaling</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># scale the data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]],</span> <span class="n">scaling</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">remaining_channels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># scale the data</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]],</span> <span class="n">scaling</span><span class="p">)</span>

        <span class="c1"># now start the blurring process for the amplitude and phase channel pairs</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting the blurring process, this might take a while...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channel_pairs</span><span class="p">)):</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">real</span> <span class="o">=</span> <span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>
            <span class="n">imag</span> <span class="o">=</span> <span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">)</span>

            <span class="c1"># compl_blurred = self._gauss_blurr_data(compl, sigma)</span>
            <span class="n">real_blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">real</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="n">imag_blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">imag</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="n">compl_blurred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">real_blurred</span><span class="p">,</span> <span class="mi">1</span><span class="n">J</span><span class="o">*</span><span class="n">imag_blurred</span><span class="p">)</span>
            <span class="n">amp_blurred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">compl_blurred</span><span class="p">)</span>
            <span class="n">phase_blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_compl_angle</span><span class="p">(</span><span class="n">compl_blurred</span><span class="p">)</span>

            <span class="c1"># update the data in memory and the labels used for plotting but not the channel names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">amp_blurred</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">phase_blurred</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channel_pairs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span>

        <span class="c1"># now start the blurring process for the remaining channels</span>
        <span class="c1"># this will blurr height, real part, imaginary part channels and amplitude channels without phase partner and phase channels without amplitude partner if the user wants to</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">remaining_channels</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">data_blurred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">data_blurred</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">remaining_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_gauss_indicator</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Blurring process finished!&#39;</span><span class="p">)</span></div>

                   
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_compl_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compl_number_array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the angles of a clomplex number array.&quot;&quot;&quot;</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compl_number_array</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compl_number_array</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">realpart</span> <span class="o">=</span> <span class="n">compl_number_array</span><span class="o">.</span><span class="n">real</span>
        <span class="n">imagpart</span> <span class="o">=</span> <span class="n">compl_number_array</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">imagpart</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">realpart</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">imagpart</span><span class="p">,</span> <span class="n">r</span><span class="o">*</span><span class="n">realpart</span><span class="p">)</span> <span class="c1">#returns values between -pi and pi, add pi for the negative values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">phase</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">phase</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="n">phase</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fourier_filter_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complex_array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Takes a complex array and returns the fourier transformed complex array</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">FS_compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">complex_array</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FS_compl</span>
    
<div class="viewcode-block" id="SnomMeasurement.fourier_filter_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.fourier_filter_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fourier_filter_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies the Fourier filter to all data in memory or specified channels</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels, will override the already existing channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;fourier_filter&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">channels_to_filter</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
                <span class="n">channels_to_filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">channels_to_filter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;In order to apply the fourier_filter amplitude and phase of the same channel number must be in the channels list!&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels_to_filter</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
            <span class="n">amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">compl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase</span><span class="p">),</span> <span class="mi">1</span><span class="n">J</span><span class="o">*</span><span class="n">amp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>
            <span class="n">FS_compl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fourier_filter_array</span><span class="p">(</span><span class="n">compl</span><span class="p">)</span>
            <span class="n">FS_compl_abs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">FS_compl</span><span class="p">)</span>
            <span class="n">FS_compl_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_compl_angle</span><span class="p">(</span><span class="n">FS_compl</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">FS_compl_abs</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_fft&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">FS_compl_angle</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels_to_filter</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_fft&#39;</span></div>


<div class="viewcode-block" id="SnomMeasurement.fourier_filter_channels_V2">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.fourier_filter_channels_V2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fourier_filter_channels_V2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function applies the Fourier filter to all data in memory or specified channels</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels, will override the already existing channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;fourier_filter&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
            <span class="n">FS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fourier_filter_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftshift</span><span class="p">(</span><span class="n">FS</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="s1">&#39;_fft&#39;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filetype</span><span class="o">=</span><span class="s1">&#39;gsf&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># channel is not in memory, so the standard values will be used</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="n">channel</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span> <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span> <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span><span class="p">,</span> <span class="n">ZReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">XOffset</span><span class="p">,</span> <span class="n">YOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># if channel is in memory it has to have a channel dict, where all necessary infos are stored</span>
            <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">XOffset</span><span class="p">,</span> <span class="n">YOffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">YRes</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">filetype</span><span class="o">==</span><span class="s1">&#39;gsf&#39;</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Gwyddion Simple Field 1.0</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">elif</span> <span class="n">filetype</span><span class="o">==</span><span class="s1">&#39;txt&#39;</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="s1">&#39;Simple Textfile, floats seperated by spaces</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1"># round everything to nm</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;XRes=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">XRes</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">YRes=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">YRes</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;XReal=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">XReal</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">YReal=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">YReal</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;XYUnits=m</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;XOffset=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">XOffset</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">6</span><span class="p">),</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">YOffset=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">YOffset</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">6</span><span class="p">),</span><span class="mi">9</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Rotation=</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;ZUnits=m</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="s1">&#39;ZUnits=</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;Title=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">measurement_title</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="c1"># lenght = header.count(&#39;\n&#39;)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="n">number</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">-</span> <span class="p">((</span><span class="n">length</span><span class="p">)</span> <span class="o">%</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">NUL</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">NUL</span> <span class="o">+=</span> <span class="sa">b</span><span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span> <span class="c1"># add NUL terminator</span>
        <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">NUL</span>

<div class="viewcode-block" id="SnomMeasurement.save_to_gsf">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.save_to_gsf">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_to_gsf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">appendix</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is ment to save all specified channels to external .gsf files.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]:    list of the channels to be saved, if not specified, all channels in memory are saved</span>
<span class="sd">                                Careful! The data will be saved as it is right now, so with all the manipulations.</span>
<span class="sd">                                Therefor the data will have an &#39;_manipulated&#39; appendix in the filename.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appendix</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">appendix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_manipulated</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="c1"># find out if channel is default or not</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_custom</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
                <span class="c1"># ignore the default appendix if the channel is not a default channel </span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_overlain</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">appendix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_synccorrected_phase</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">appendix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;channel not found in default or custom channels&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">channel</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}{</span><span class="n">appendix</span><span class="si">}</span><span class="s1">.gsf&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
            <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">YRes</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_header</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;bw&#39;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">NUL</span><span class="p">)</span> <span class="c1"># the NUL marks the end of the header and konsists of 0 characters in the first dataline</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">],</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="o">-</span><span class="mi">9</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                        <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">],</span> <span class="mi">5</span><span class="p">)))</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;successfully saved channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> to .gsf&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;save_to_gsf_appendix&#39;</span><span class="p">,</span> <span class="n">appendix</span><span class="p">)</span></div>


<div class="viewcode-block" id="SnomMeasurement.save_to_txt">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.save_to_txt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">save_to_txt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">appendix</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is ment to save all specified channels to external .txt files.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]:    list of the channels to be saved, if not specified, all channels in memory are saved</span>
<span class="sd">                                Careful! The data will be saved as it is right now, so with all the manipulations.</span>
<span class="sd">                                Therefor the data will have an &#39;_manipulated&#39; appendix in the filename.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">appendix</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">appendix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_manipulated</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
            <span class="k">elif</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_custom</span><span class="p">:</span>
                <span class="n">suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span>
                <span class="n">channel_type</span> <span class="o">=</span> <span class="s1">&#39;custom&#39;</span>
                <span class="c1"># ignore the default appendix if the channel is not a default channel </span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_overlain</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">appendix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_synccorrected_phase</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">appendix</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;channel not found in default or custom channels&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
            
            <span class="n">filepath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">channel</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}{</span><span class="n">appendix</span><span class="si">}</span><span class="s1">.txt&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
            <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">YRes</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_header</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="s1">&#39;txt&#39;</span><span class="p">)</span>
            <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="c1"># file.write(NUL) # the NUL marks the end of the header and konsists of 0 characters in the first dataline</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">],</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="si">}</span><span class="s1"> &#39;</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;successfully saved channel </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1"> to .txt&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;save_to_txt_appendix&#39;</span><span class="p">,</span> <span class="n">appendix</span><span class="p">)</span></div>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_synccorr_preview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">,</span> <span class="n">nouserinput</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is part of the synccorrection and creates a preview of the corrected data.</span>
<span class="sd">        channel specifies which channel should be used for the preview.</span>
<span class="sd">        Wavelength must be given in m.</span>
<span class="sd">        Scanangle is the rotation angle of the scan in radians.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scanangle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
        <span class="n">phasedir_positive</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">phasedir_negative</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_data</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">phase_positive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="n">phase_negative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="n">phase_no_correction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">YRes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">XRes</span><span class="p">):</span>
                <span class="n">xreal</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">XReal</span><span class="o">/</span><span class="n">XRes</span>
                <span class="n">yreal</span><span class="o">=</span><span class="n">y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">YReal</span><span class="o">/</span><span class="n">YRes</span>
                <span class="c1">#phase accumulated by movement of parabolic mirror only depends on &#39;x&#39; direction</span>
                <span class="n">phase_no_correction</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                <span class="n">phase_positive</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">phasedir_positive</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">xreal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">yreal</span><span class="p">)</span><span class="o">/</span><span class="n">wavelength</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                <span class="n">phase_negative</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">phasedir_negative</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">xreal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">yreal</span><span class="p">)</span><span class="o">/</span><span class="n">wavelength</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1">#create plots of the uncorrected and corrected images</span>
        <span class="n">subplots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_subplot</span><span class="p">(</span><span class="n">phase_no_correction</span><span class="p">,</span> <span class="n">channel</span><span class="p">))</span>
        <span class="n">subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_subplot</span><span class="p">(</span><span class="n">phase_positive</span><span class="p">,</span> <span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_positive&#39;</span><span class="p">))</span>
        <span class="n">subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_subplot</span><span class="p">(</span><span class="n">phase_negative</span><span class="p">,</span> <span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_negative&#39;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_subplots</span><span class="p">(</span><span class="n">subplots</span><span class="p">)</span>
        <span class="c1"># remove the preview subplots from the subplot memory after plotting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_last_subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="c1">#ask the user to chose a correction direction</span>
        <span class="k">if</span> <span class="n">nouserinput</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">phasedir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_from_input_phasedir</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">phasedir</span>

<div class="viewcode-block" id="SnomMeasurement.synccorrection">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.synccorrection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">synccorrection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">phasedir</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function corrects all the phase channels for the linear phase gradient</span>
<span class="sd">        which stems from the synchronized measurement mode.</span>
<span class="sd">        The wavelength must be given in m.</span>
<span class="sd">        The phasedir is either 1 or -1. If you are unshure about the direction just leave the parameter out.</span>
<span class="sd">        You will be shown a preview for both directions and then you must choose the correct one.</span>
<span class="sd">        The synccorrection will then be applied to all phase channels in memory.</span>
<span class="sd">        The corrected channels will then be saved as new files with the synccorrection appendix specified in the config.ini file.</span>
<span class="sd">        Afterwards the original channels and data will be reloaded in memory.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            wavelenght (float): please enter the wavelength in m.</span>
<span class="sd">            phasedir (int): the phase direction, leave out if not known and you will be prompted with a preview and can select the appropriate direction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoscale</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;careful! The synccorretion does not work when autoscale is enabled.&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># now load all channels in memory for the synccorrection, but save the original data and channels and reinitialize the data lateron</span>
        <span class="n">old_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">old_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">old_channel_tag_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">old_channels_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">old_measurement_tag_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># load new channels for synccorrection</span>
        <span class="n">all_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">all_channels</span><span class="p">)</span>
        <span class="n">scanangle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">ROTATION</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
        <span class="k">if</span> <span class="n">phasedir</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phasedir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_synccorr_preview</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;synccorrection_wavelength&#39;</span><span class="p">,</span> <span class="n">wavelength</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;synccorrection_phasedir&#39;</span><span class="p">,</span> <span class="n">phasedir</span><span class="p">)</span>
        <span class="n">header</span><span class="p">,</span> <span class="n">NUL</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">)</span> <span class="c1"># channel for header just important to distinguish z axis unit either m or nothing</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="n">phasef</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_corrected.gsf&#39;</span><span class="p">),</span> <span class="s1">&#39;bw&#39;</span><span class="p">)</span>
            <span class="n">realf</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">real_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">_corrected.gsf&#39;</span><span class="p">),</span> <span class="s1">&#39;bw&#39;</span><span class="p">)</span>
            <span class="n">phasef</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
            <span class="n">realf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span>
            <span class="n">phasef</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">NUL</span><span class="p">)</span> <span class="c1"># add NUL terminator</span>
            <span class="n">realf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">NUL</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="c1">#convert pixel number to realspace coordinates in m</span>
                    <span class="n">xreal</span><span class="o">=</span><span class="n">x</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">XReal</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">XRes</span>
                    <span class="n">yreal</span><span class="o">=</span><span class="n">y</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">YReal</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">YRes</span>
                    <span class="c1">#open the phase, add pi to change the range from 0 to 2 pi and then substract the linear phase gradient, which depends on the scanangle!</span>
                    <span class="n">amppixval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                    <span class="n">phasepixval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                    <span class="n">phasepixval_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">phasepixval</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phasedir</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">xreal</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="o">-</span><span class="n">scanangle</span><span class="p">)</span><span class="o">*</span><span class="n">yreal</span><span class="p">)</span><span class="o">/</span><span class="n">wavelength</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                    <span class="n">realpixval</span> <span class="o">=</span> <span class="n">amppixval</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phasepixval_corr</span><span class="p">)</span>
                    <span class="n">phasef</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span><span class="n">phasepixval_corr</span><span class="p">))</span>
                    <span class="n">realf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span><span class="n">realpixval</span><span class="p">))</span>
            <span class="n">phasef</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">realf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># reinitialize the old data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">old_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="n">old_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span> <span class="o">=</span> <span class="n">old_channel_tag_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span> <span class="o">=</span> <span class="n">old_channels_label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measurement_tag_dict</span> <span class="o">=</span> <span class="n">old_measurement_tag_dict</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_gen_from_input_phasedir</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function asks the user to input a phase direction, input must be either n or p, for negative or positive respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phasedir</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Did you prefer the negative or positive phase direction? Please enter either </span><span class="se">\&#39;</span><span class="s1">n</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">p</span><span class="se">\&#39;\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">phasedir</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">phasedir</span> <span class="o">==</span> <span class="s1">&#39;p&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Wrong letter! Please try again.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gen_from_input_phasedir</span><span class="p">()</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_channel_scaling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_id</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function checks if an instance channel is scaled and returns the scaling factor.&quot;&quot;&quot;</span>
        <span class="n">channel_yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel_id</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">channel_yres</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">YRes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_height_mask_preview</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function creates a preview of the height masking.</span>
<span class="sd">        The preview is based on all channels in the instance&quot;&quot;&quot;</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span>
        <span class="n">subplots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask_array</span><span class="p">)</span>
            <span class="n">subplots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_subplot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">masked_array</span><span class="p">),</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_subplots</span><span class="p">(</span><span class="n">subplots</span><span class="p">)</span>
        <span class="c1"># remove the preview subplots from the memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_last_subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        
    <span class="k">def</span><span class="w"> </span><span class="nf">_user_input_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span> 
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function asks the user to input yes or no and returns a boolean value.&quot;&quot;&quot;</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Please type y for yes or n for no. </span><span class="se">\n</span><span class="s1">Input: &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">user_bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">user_input</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">user_bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">user_bool</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_user_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function confronts the user with the specified message and returns the user input</span>

<span class="sd">        Args:</span>
<span class="sd">            message (str): the message to display</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">input</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_create_mask_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function takes the height data and a threshold value to create a mask array containing 0 and 1 values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">height_flattened</span> <span class="o">=</span> <span class="n">height_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">height_threshold</span> <span class="o">=</span> <span class="n">threshold</span><span class="o">*</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">height_flattened</span><span class="p">)</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">height_flattened</span><span class="p">))</span><span class="o">+</span><span class="nb">min</span><span class="p">(</span><span class="n">height_flattened</span><span class="p">)</span>

        <span class="c1"># create an array containing 0 and 1 depending on wether the height value is below or above threshold</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">height_threshold</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">mask_array</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">mask_array</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_height_treshold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_data</span><span class="p">,</span> <span class="n">mask_array</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the height threshold value dependent on the user input&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_height_mask_preview</span><span class="p">(</span><span class="n">mask_array</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to use these parameters to mask the data?&#39;</span><span class="p">)</span>
        <span class="n">mask_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mask_data</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to change the treshold?&#39;</span><span class="p">)</span>
            <span class="n">change_treshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">change_treshold</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The old threshold was </span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Please enter the new treshold value: &#39;</span><span class="p">))</span>
                <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_mask_array</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_height_treshold</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">mask_array</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to abort the masking procedure?&#39;</span><span class="p">)</span>
                <span class="n">abort</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">abort</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">exit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">threshold</span>

<div class="viewcode-block" id="SnomMeasurement.heigth_mask_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.heigth_mask_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">heigth_mask_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mask_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">export</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The treshold factor should be between 0 and 1. It sets the threshold for the height pixels.</span>
<span class="sd">        Every pixel below threshold will be set to 0. This also applies for all other channels. </span>
<span class="sd">        You can either specify specific channels to mask or if you don&#39;t specify channels,</span>
<span class="sd">        all standard channels will be masked. If export is False only the channels in self.channels will be masked</span>
<span class="sd">        and nothing will be exported. </span>
<span class="sd">        For this function to also work with scaled data the height channel has to be specified and scaled as well!</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels, will override the already existing channels</span>
<span class="sd">            threshold [float]: threshold value to create the height mask from</span>
<span class="sd">            mask_data [bool]: if you want to apply the mask directly with the specified threshold change to &#39;True&#39;,</span>
<span class="sd">                            otherwise you will be prompted with a preview and can then change the threshold iteratively</span>
<span class="sd">            export [bool]: if you want to apply the mask to all channels and export them change to &#39;True&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mask_channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">mask_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)]</span>
                <span class="k">if</span> <span class="s1">&#39;leveled&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)]:</span>
                    <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="n">height_data</span> <span class="c1"># since height_data is already leveled</span>
                
                <span class="c1"># if the height channel is used in the instance for example with gaussian blurr, this data will be used and not the raw data</span>
                <span class="c1"># because the data might be scaled, careful to always use the corrected height channel &#39;Z C&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">height_data</span><span class="p">,</span> <span class="n">trash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">])</span>
                <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">mask_channel</span><span class="p">)])</span>

        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_mask_array</span><span class="p">(</span><span class="n">leveled_height_data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

        
        <span class="k">if</span> <span class="n">mask_data</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_height_treshold</span><span class="p">(</span><span class="n">leveled_height_data</span><span class="p">,</span> <span class="n">mask_array</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
            <span class="n">mask_data</span> <span class="o">==</span> <span class="kc">True</span> <span class="c1">#unnecessary from now on...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;height_masking_threshold&#39;</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_mask_array</span><span class="p">(</span><span class="n">leveled_height_data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">mask_array</span> <span class="c1"># todo, mask array must be saved as part of the image, otherwise multiple measurement creations will use the same mask</span>
        <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># open files for the masked data:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="n">header</span><span class="p">,</span> <span class="n">NUL</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_header</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">trash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="n">channel</span><span class="p">])</span>
                <span class="n">datafile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_masked.gsf&#39;</span><span class="p">),</span><span class="s2">&quot;bw&quot;</span><span class="p">)</span>
                <span class="n">datafile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
                <span class="n">datafile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">NUL</span><span class="p">)</span>
                <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mask_array</span><span class="p">)</span>
                <span class="n">flattened_data</span> <span class="o">=</span> <span class="n">masked_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">pixeldata</span> <span class="ow">in</span> <span class="n">flattened_data</span><span class="p">:</span>
                    <span class="n">datafile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">pixeldata</span><span class="p">))</span>
                <span class="n">datafile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;All channels have been masked and exported!&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">export</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Channels in memory have been masked!&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mask_array</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_masked&#39;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_pixel_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function checks if the pixel position is within the bounds&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">xres</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">yres</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_mean_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">x_coord</span><span class="p">,</span> <span class="n">y_coord</span><span class="p">,</span> <span class="n">zone</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the mean value of the pixel and its nearest neighbors.</span>
<span class="sd">        The zone specifies the number of neighbors. 1 means the pixel and the 8 nearest pixels.</span>
<span class="sd">        2 means zone 1 plus the next 16, so a total of 25 with the pixel in the middle. </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">zone</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                <span class="n">y_pixel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_coord</span> <span class="o">-</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
                <span class="n">x_pixel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_coord</span> <span class="o">-</span><span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_pixel_position</span><span class="p">(</span><span class="n">xres</span><span class="p">,</span> <span class="n">yres</span><span class="p">,</span> <span class="n">x_pixel</span><span class="p">,</span> <span class="n">y_pixel</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">mean</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">y_pixel</span><span class="p">][</span><span class="n">x_pixel</span><span class="p">]</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">mean</span><span class="o">/</span><span class="n">count</span>

<div class="viewcode-block" id="SnomMeasurement.get_pixel_coordinates">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.get_pixel_coordinates">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pixel_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the pixel coordinates of the clicked pixel.&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
        <span class="c1"># identify the colormap</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_height</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_phase</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_amplitude</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Please click on the pixel you want to get the coordinates from.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span> <span class="c1">#klicker returns a dictionary for the events</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
        <span class="c1"># display image with the clicked pixel</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;You clicked on the following pixel.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">coordinates</span></div>


<div class="viewcode-block" id="SnomMeasurement.get_pixel_value">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.get_pixel_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_pixel_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zone</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function returns the pixel value of a channel at the specified coordinates.</span>
<span class="sd">        The zone specifies the number of neighbors. 0 means only the pixel itself. 1 means the pixel and the 8 nearest pixels.</span>
<span class="sd">        2 means zone 1 plus the next 16, so a total of 25 with the pixel in the middle.</span>
<span class="sd">        If the channel is scaled the zone will be scaled as well.&quot;&quot;&quot;</span>
        <span class="c1"># adjust the zone if the data is scaled</span>
        <span class="n">zone</span> <span class="o">=</span> <span class="n">zone</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_scaling</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">))</span>
        <span class="c1"># display the channel</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">coordinates</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_coordinates</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You need to specify one pixel coordinate! </span><span class="se">\n</span><span class="s1">Do you want to try again?&#39;</span><span class="p">)</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_pixel_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">zone</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># get the mean value of the pixel and its neighbors</span>
        <span class="n">pixel_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_mean_value</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">zone</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pixel_value</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_height_levelling_3point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_data</span><span class="p">,</span> <span class="n">zone</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_height</span><span class="p">)</span>
        <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;3 Point leveling: please click on three points</span><span class="se">\n</span><span class="s1">to specify the underground plane.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span> <span class="c1">#klicker returns a dictionary for the events</span>
        <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;height_leveling_coordinates&#39;</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You need to specify 3 point coordinates! </span><span class="se">\n</span><span class="s1">Do you want to try again?&#39;</span><span class="p">)</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point</span><span class="p">(</span><span class="n">zone</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># for the 3 point coordinates the height data is calculated over a small area around the clicked pixels to reduce deviations due to noise</span>
        <span class="n">mean_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mean_value</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">zone</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">))]</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mean_values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span> <span class="c1"># not sure why, 100 is a bit random, but 0 didn&#39;t work</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># create a plane with same dimensions as the height_data</span>
        <span class="n">plane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="p">,</span> <span class="n">xres</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">plane_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">solution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">solution</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="p">,</span> <span class="n">xres</span><span class="p">))</span>
        <span class="c1"># substract the plane_data from the height_data</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">leveled_height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">leveled_height_data</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_level_height_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_data</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">,</span> <span class="n">zone</span><span class="p">):</span>
        <span class="n">mean_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mean_value</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">zone</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">))]</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">mean_values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span> <span class="c1"># not sure why, 100 is a bit random, but 0 didn&#39;t work</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># create a plane with same dimensions as the height_data</span>
        <span class="n">plane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="p">,</span> <span class="n">xres</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">plane_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">solution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">solution</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="p">,</span> <span class="n">xres</span><span class="p">))</span>
        <span class="c1"># substract the plane_data from the height_data</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">leveled_height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">leveled_height_data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_klicker_coordinates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="p">):</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;3 Point leveling: please click on three points</span><span class="se">\n</span><span class="s1">to specify the underground plane.&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span> <span class="c1">#klicker returns a dictionary for the events</span>
        <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">klick_coordinates</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_height_levelling_3point_forGui</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_data</span><span class="p">,</span> <span class="n">zone</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_klicker_coordinates</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">SNOM_height</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You need to specify 3 point coordinates! Data was not leveled!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">height_data</span>
        <span class="c1"># for the 3 point coordinates the height data is calculated over a small area around the clicked pixels to reduce deviations due to noise</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;height_leveling_coordinates&#39;</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_height_data</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">,</span> <span class="n">zone</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_level_phase_slope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">slope</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function substracts a linear phase gradient in y direction from the specified phase data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">-=</span> <span class="n">y</span><span class="o">*</span><span class="n">slope</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<div class="viewcode-block" id="SnomMeasurement.correct_phase_drift">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.correct_phase_drift">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correct_phase_drift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">export</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">phase_slope</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zone</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function asks the user to click on two points which should have the same phase value.</span>
<span class="sd">        Only the slow drift in y-direction will be compensated. Could in future be extended to include a percentual drift compensation along the x-direction.</span>
<span class="sd">        But should usually not be necessary.</span>
<span class="sd">                </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels, will override the already existing channels</span>
<span class="sd">            export [bool]: do you want to aply the correction to all phase channels and export them?</span>
<span class="sd">            phase_slope [float]: if you already now the phase slope you can enter it, otherwise leave it out</span>
<span class="sd">                                and it will prompt you with a preview to select two points to calculate the slope from</span>
<span class="sd">            zone [int]: defines the area which is used to calculate the mean around the click position in the preview,</span>
<span class="sd">                        0 means only the click position, 1 means the nearest 9 ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">)])</span>
            <span class="n">phase_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">phase_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span>
        <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># ToDo</span>
            <span class="c1"># do something with the phase slope...</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You want to export a phase slope correction, but nothing happens!&#39;</span><span class="p">)</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">phase_slope</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#level all phase channels in memory...</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;phase_driftcomp_slope&#39;</span><span class="p">,</span> <span class="n">phase_slope</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="s1">&#39;P&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_phase_slope</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">phase_slope</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_driftcomp&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
                <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
                <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase leveling: please click on two points</span><span class="se">\n</span><span class="s1">to specify the phase drift.&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span> <span class="c1">#klicker returns a dictionary for the events</span>
                <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You must specify two points which should have the same phase, along the y-direction&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to try again?&#39;</span><span class="p">)</span>
                    <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">correct_phase_drift</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">export</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span> 
                        <span class="n">exit</span><span class="p">()</span>
                <span class="n">mean_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_mean_value</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">zone</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">))]</span>
                <span class="c1">#order points from top to bottom</span>
                <span class="k">if</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">second_corrd</span> <span class="o">=</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">second_mean</span> <span class="o">=</span> <span class="n">mean_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_corrd</span>
                    <span class="n">mean_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">mean_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">second_mean</span>
                <span class="n">phase_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">mean_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">leveled_phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_level_phase_slope</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="n">phase_slope</span><span class="p">)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">leveled_phase_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
                <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
                <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
                <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Leveled Pase: &#39;</span> <span class="o">+</span> <span class="n">phase_channel</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you satisfied with the phase leveling?&#39;</span><span class="p">)</span>
                <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#use the phase slope to level all phase channels in memory</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">correct_phase_drift</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">phase_slope</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to repeat the leveling?&#39;</span><span class="p">)</span>
                    <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="c1">#start the leveling process again</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">correct_phase_drift</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">exit</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.correct_phase_drift_nonlinear">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.correct_phase_drift_nonlinear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correct_phase_drift_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function corrects the phase drift in the y-direction by using a reference area across the full length of the scan.	</span>
<span class="sd">        The reference area is used to calculate the average phase value per row.</span>
<span class="sd">        This value is then substracted from the phase data to level the phase.</span>
<span class="sd">        The reference area is specified by two coordinates, the left and right border. If no area is specified the whole image will be used.</span>
<span class="sd">        Make shure not to rotate the image prior to this function, since the reference area is defined in y-direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): list of channels, will override the already existing channels</span>
<span class="sd">            reference_area (list, optional): The reference area to calculate the phase offset, specify as reference_area=[left-border, right-border].</span>
<span class="sd">                If not specified the whole image will be used. Defaults to [None, None].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if a list of channels is specified those will be loaded and the old ones will be overwritten</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="c1"># define local list of channels to use for leveling</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">)])</span>
            <span class="n">phase_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">phase_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span>
        
        <span class="c1"># cut out the reference area</span>
        <span class="c1"># if no area is specified just use the whole data</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># left border</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># right border</span>

        <span class="c1"># get the phase values per column of the reference area, then flatten each column </span>
        <span class="n">flattened_phase_profiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">reference_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phase_data</span><span class="p">))]</span>
            <span class="n">reference_values_flattened</span> <span class="o">=</span> <span class="n">phase_analysis</span><span class="o">.</span><span class="n">flatten_phase_profile</span><span class="p">(</span><span class="n">reference_values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># reference_values_flattened = np.unwrap(reference_values)</span>
            <span class="n">flattened_phase_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reference_values_flattened</span><span class="p">)</span>

        <span class="c1"># average all flattened profiles</span>
        <span class="n">reference_values_flattened</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">flattened_phase_profiles</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># remove the averaged reference data per line from the phase data</span>
        <span class="n">leveled_phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">phase_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phase_data</span><span class="p">)):</span>
            <span class="n">leveled_phase_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">leveled_phase_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">reference_values_flattened</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># display the leveled phase data</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">leveled_phase_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;10%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="c1"># ax.legend()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Leveled Pase: &#39;</span> <span class="o">+</span> <span class="n">phase_channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you satisfied with the phase leveling?&#39;</span><span class="p">)</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># write to logfile</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;phase_driftcomp_nonlinear_reference_area&#39;</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
            <span class="c1"># do the leveling for all channels but use always the same reference data, channels should only differ in phase offset</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="s1">&#39;P&#39;</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">reference_values_flattened</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_values_flattened</span><span class="p">))]</span>
                    <span class="c1"># also apply a phase shift to ensure that the phase is between 0 and 2pi</span>
                    <span class="c1"># for now take the average phase an shift it to pi/2 should be white on the colormap</span>
                    <span class="n">phase_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="n">phase_shift</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.match_phase_offset">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.match_phase_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match_phase_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manual_width</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function matches the phase offset of all phase channels in memory to the reference channel.</span>
<span class="sd">        The reference channel is the first phase channel in memory if not specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): list of channels, will override the already existing channels</span>
<span class="sd">            reference_channel ([type], optional): The reference channel to which all other phase channels will be matched.</span>
<span class="sd">                If not specified the first phase channel in memory will be used. Defaults to None.</span>
<span class="sd">            reference_area ([type], optional): The area in the reference channel which will be used to calculate the phase offset. If not specified the whole image will be used.</span>
<span class="sd">                You can also specify &#39;manual&#39; then you will be asked to click on a point in the image. The area around that pixel will then be used as reference. Defaults to None.</span>
<span class="sd">            manual_width (int, optional): The width of the manual reference area. Only applies if reference_area=&#39;manual&#39;. Defaults to 5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if a list of channels is specified those will be loaded and the old ones will be overwritten</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="c1"># define local list of channels to use for leveling</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">reference_channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">reference_channel</span> <span class="o">=</span> <span class="n">channel</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">reference_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># reference_area = [[xmin, xmax][ymin, ymax]]</span>
            <span class="n">reference_area</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)][</span><span class="mi">0</span><span class="p">])],[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)])]]</span>
        <span class="k">elif</span> <span class="n">reference_area</span> <span class="o">==</span> <span class="s1">&#39;manual&#39;</span><span class="p">:</span>
            <span class="c1"># use pointcklicker to get the reference area</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
            <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Please click in the area to use as reference.&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span>
            <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
            <span class="c1"># make sure only one point is selected</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You must specify one point which should define the reference area!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to try again?&#39;</span><span class="p">)</span>
                <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">match_phase_offset</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">,</span> <span class="s1">&#39;manual&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exit</span><span class="p">()</span>
            <span class="n">reference_area</span> <span class="o">=</span> <span class="p">[[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">manual_width</span><span class="p">,</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">manual_width</span><span class="p">],[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">manual_width</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">manual_width</span><span class="p">]]</span>
        
        <span class="n">reference_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">reference_channel</span><span class="p">)]</span>
        <span class="n">reference_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">reference_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])])</span>
        
        <span class="c1"># display the reference area</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">reference_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>  
        <span class="n">rect</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Reference Area: &#39;</span> <span class="o">+</span> <span class="n">reference_channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
                <span class="c1"># phase_offset = np.mean(phase_data) - reference_phase</span>
                <span class="n">phase_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">phase_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])])</span> <span class="o">-</span> <span class="n">reference_phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="o">-</span><span class="n">phase_offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;match_phase_offset_reference_area&#39;</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.correct_amplitude_drift_nonlinear">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.correct_amplitude_drift_nonlinear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correct_amplitude_drift_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function corrects the amplitude drift in the y-direction by using a reference area across the full length of the scan.	</span>
<span class="sd">        The reference area is used to calculate the average amplitude value per row.</span>
<span class="sd">        This value is then divided from the amplitude data to level the amplitude.</span>
<span class="sd">        The reference area is specified by two coordinates, the left and right border. If no area is specified the whole image will be used.</span>
<span class="sd">        Make shure not to rotate the image prior to this function, since the reference area is defined in y-direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): list of channels, will override the already existing channels</span>
<span class="sd">            reference_area (list, optional): The reference area to calculate the amplitude offset, specify as reference_area=[left-border, right-border].</span>
<span class="sd">                If not specified the whole image will be used. Defaults to [None, None].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if a list of channels is specified those will be loaded and the old ones will be overwritten</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="c1"># define local list of channels to use for leveling</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">amplitude_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">amplitude_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span><span class="p">)])</span>
            <span class="n">amplitude_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">amplitude_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">amplitude_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_ampchannel</span>
        
        <span class="c1"># cut out the reference area</span>
        <span class="c1"># if no area is specified just use the whole data</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># iterate through the reference area and get the average amplitude value per row</span>
        <span class="n">reference_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">))]</span>

        <span class="c1"># we assume the average amplitude should stay constant, so we divide the amplitude data by the reference values and multiply by the mean reference value</span>
        <span class="n">leveled_amplitude_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">)):</span>
            <span class="n">leveled_amplitude_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">amplitude_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">reference_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_values</span><span class="p">)</span>
        
        <span class="c1"># display the original data besides the leveled amplitude data</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">img1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">amplitude_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_amplitude</span><span class="p">)</span>
        <span class="n">img2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">leveled_amplitude_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_amplitude</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="c1"># ax[0].legend()</span>
        <span class="c1"># ax[1].legend()</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original Amplitude: &#39;</span> <span class="o">+</span> <span class="n">amplitude_channel</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Leveled Amplitude: &#39;</span> <span class="o">+</span> <span class="n">amplitude_channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># ask the user if he is satisfied with the leveling</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you satisfied with the amplitude leveling?&#39;</span><span class="p">)</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># do the leveling for all channels, each channel should be referenced to itself since the amplitudes of the channels will be different</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># self.all_data[self.channels.index(channels[i])] = np.copy(self.all_data[self.channels.index(channels[i])])</span>
                    <span class="n">reference_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">j</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]))]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">reference_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_values</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_values</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to repeat the leveling?&#39;</span><span class="p">)</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># write to logfile</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;amplitude_driftcomp_nonlinear_reference_area&#39;</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
                <span class="c1">#start the leveling process again</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correct_amplitude_drift_nonlinear</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.correct_height_drift_nonlinear">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.correct_height_drift_nonlinear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">correct_height_drift_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">:</span><span class="nb">list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function corrects the height drift in the y-direction by using a reference area across the full length of the scan.	</span>
<span class="sd">        The reference area is used to calculate the average height value per row.</span>
<span class="sd">        This value is then divided from the height data to level the height.</span>
<span class="sd">        The reference area is specified by two coordinates, the left and right border. If no area is specified the whole image will be used.</span>
<span class="sd">        Make shure not to rotate the image prior to this function, since the reference area is defined in y-direction.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): list of channels, will override the already existing channels</span>
<span class="sd">            reference_area (list, optional): The reference area to calculate the height offset, specify as reference_area=[left-border, right-border].</span>
<span class="sd">                If not specified the whole image will be used. Defaults to [None, None].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># zone = int(zone*self.scaling_factor/4) #automatically enlargen the zone if the data has been scaled by more than a factor of 4</span>
        <span class="c1"># if a list of channels is specified those will be loaded and the old ones will be overwritten</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="c1"># define local list of channels to use for leveling</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">height_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)])</span>
            <span class="n">height_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">height_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
        
        <span class="c1"># cut out the reference area</span>
        <span class="c1"># new version: let the user specify the reference area by moving two borders in the preview</span>
        <span class="c1"># if no area is specified just use the whole data</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># iterate through the reference area and get the average height value per row</span>
        <span class="n">reference_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">))]</span>

        <span class="c1"># we assume the average height should stay constant, so we divide the height data by the reference values and multiply by the mean reference value</span>
        <span class="n">leveled_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">)):</span>
            <span class="n">leveled_height_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">reference_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_values</span><span class="p">)</span>
        
        <span class="c1"># display the original data besides the leveled height data</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">img1</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_height</span><span class="p">)</span>
        <span class="n">img2</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">leveled_height_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_height</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="c1"># ax[0].legend()</span>
        <span class="c1"># ax[1].legend()</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original height: &#39;</span> <span class="o">+</span> <span class="n">height_channel</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Leveled height: &#39;</span> <span class="o">+</span> <span class="n">height_channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># ask the user if he is satisfied with the leveling</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you satisfied with the height leveling?&#39;</span><span class="p">)</span>
        <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># do the leveling for all channels, each channel should be referenced to itself since the heights of the channels will be different</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="c1"># self.all_data[self.channels.index(channels[i])] = np.copy(self.all_data[self.channels.index(channels[i])])</span>
                    <span class="n">reference_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">j</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]))]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">i</span><span class="p">])][</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">reference_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_values</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reference_values</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to repeat the leveling?&#39;</span><span class="p">)</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># write to logfile</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;height_driftcomp_nonlinear_reference_area&#39;</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
                <span class="c1">#start the leveling process again</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correct_height_drift_nonlinear</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.level_height_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.level_height_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">level_height_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function levels all height channels which are either user specified or in the instance memory.</span>
<span class="sd">        The leveling will prompt the user with a preview to select 3 points for getting the coordinates of the leveling plane.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to level. If not specified all channels in memory will be used. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+=</span> <span class="s1">&#39;_leveled&#39;</span> 
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.level_height_channels_forGui">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.level_height_channels_forGui">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">level_height_channels_forGui</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span><span class="c1"># todo not used?</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function levels all height channels which are either user specified or in the instance memory.</span>
<span class="sd">        The leveling will prompt the user with a preview to select 3 points for getting the coordinates of the leveling plane.</span>
<span class="sd">        This function is specifically for use with GUI.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels to level. If not specified all channels in memory will be used. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_height_levelling_3point_forGui</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+=</span> <span class="s1">&#39;_leveled&#39;</span> 
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_shift_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds a phaseshift to the specified phase data. The phase data is automatically kept in the 0 to 2 pi range.</span>
<span class="sd">        Could in future be extended to show a live view of the phase data while it can be modified by a slider...</span>
<span class="sd">        e.g. by shifting the colorscale in the preview rather than the actual data...&quot;&quot;&quot;</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="SnomMeasurement.shift_phase">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.shift_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will prompt the user with a preview of the first phase channel in memory.</span>
<span class="sd">        Under the preview is a slider, by changing the slider value the phase preview will shift accordingly.</span>
<span class="sd">        If you are satisfied with the shift, hit the &#39;accept&#39; button. The preview will close and the shift will</span>
<span class="sd">        be applied to all phase channels in memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            shift (float, optional): If you know the shift value already, you can enter values between 0 and 2*Pi</span>
<span class="sd">            channels (list, optional): List of channels to apply the shift to, only phase channels will be shifted though.</span>
<span class="sd">                If not specified all channels in memory will be used. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">shift_known</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">)])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># check if corrected phase channel is present</span>
                <span class="c1"># just take the first phase channel in memory</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                        <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>
                        <span class="k">break</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">get_phase_offset</span><span class="p">(</span><span class="n">phase_data</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The phase shift you chose is:&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># export shift value to logfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;phase_shift&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
        <span class="c1"># shift all phase channels in memory</span>
        <span class="c1"># could also be implemented to shift each channel individually...</span>
        
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Before phase shift: &#39;</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Min phase value:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max phase value:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="n">shift</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;After phase shift: &#39;</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Min phase value:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max phase value:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]))</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_horizontal_wg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1">#just calculate the shift for each pixel for now</span>
        <span class="n">number_align_points</span> <span class="o">=</span> <span class="n">XRes</span> <span class="c1">#the number of intersections fitted with gaussian to find waveguide center along the x direction</span>
        <span class="n">align_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">XRes</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">XRes</span><span class="p">)</span><span class="o">/</span><span class="n">number_align_points</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">cutline_data_sets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">align_points</span><span class="p">:</span>
            <span class="n">cutline</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                <span class="n">cutline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">element</span><span class="p">])</span>
            <span class="n">cutline_data_sets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutline</span><span class="p">)</span>
        <span class="n">list_of_coefficients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="n">YRes</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">YRes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000</span><span class="p">],</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">YRes</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">cutline</span> <span class="ow">in</span> <span class="n">cutline_data_sets</span><span class="p">:</span>
            <span class="n">coeff</span><span class="p">,</span> <span class="n">var_matrix</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">gauss_function</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">YRes</span><span class="p">),</span> <span class="n">cutline</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">p0</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
            <span class="n">list_of_coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">coeff</span> <span class="c1">#set the starting parameters for the next fit</span>
        <span class="k">return</span> <span class="n">align_points</span><span class="p">,</span> <span class="n">list_of_coefficients</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_shift_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">y_shifts</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">min_shift</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">))</span>
        <span class="n">max_shift</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">))</span>
        <span class="n">new_YRes</span> <span class="o">=</span> <span class="n">YRes</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">min_shift</span><span class="o">-</span><span class="n">max_shift</span><span class="p">))</span>
        <span class="n">data_shifted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">new_YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="c1">#create the realigned height</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
            <span class="n">y_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="n">y_shifts</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">max_shift</span><span class="p">))</span> <span class="c1">#the calculated shift has to be compensated by shifting the pixels</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                <span class="n">data_shifted</span><span class="p">[</span><span class="n">y</span> <span class="o">+</span> <span class="n">y_shift</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_shifted</span>

<div class="viewcode-block" id="SnomMeasurement.realign">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.realign">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">realign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function corrects the drift of the piezo motor. As of now it needs to be fitted to a region of the sample which is assumed to be straight.</span>
<span class="sd">        In the future this could be implemented with a general map containing the distortion created by the piezo motor, if it turns out to be constant...</span>
<span class="sd">        Anyways, you will be prompted with a preview of the height data, please select an area of the scan with only one &#39;straight&#39; waveguide. </span>
<span class="sd">        The bounds for the fitting routine are based on the lower and upper limit of this selection.</span>

<span class="sd">        Careful! Will not yet affect the scan size, so the pixelsize will be altered... ToDo</span>
<span class="sd">        </span>
<span class="sd">        Args:  </span>
<span class="sd">            channels [list]: list of channels, will override the already existing channels</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="c1"># store the bounds in the instance so the plotting algorithm can access them</span>
        <span class="c1"># get the bounds from drawing a rectangle:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">trash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">])</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">select_rectangle</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_y_bound</span> <span class="o">=</span> <span class="n">lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_y_bound</span> <span class="o">=</span> <span class="n">upper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;realign_bounds&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">height_data_array</span><span class="p">,</span> <span class="n">trash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">])</span>
            <span class="n">height_data</span> <span class="o">=</span> <span class="n">height_data_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if the channels have been scaled, the height has to be scaled as well</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_scaling</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scaling</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_array</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">reduced_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">upper</span><span class="o">-</span><span class="n">lower</span> <span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">XRes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">lower</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="n">upper</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">reduced_height_data</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="n">lower</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        <span class="n">align_points</span><span class="p">,</span> <span class="n">fit_coefficients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_horizontal_wg</span><span class="p">(</span><span class="n">reduced_height_data</span><span class="p">)</span>
        <span class="n">y_shifts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span><span class="nb">int</span><span class="p">((</span><span class="n">upper</span> <span class="o">-</span> <span class="n">lower</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">fit_coefficients</span><span class="p">]</span>
        <span class="c1"># save the align points and y_shifts as instance variables so the plotting algorithm can access them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">align_points</span> <span class="o">=</span> <span class="n">align_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_shifts</span> <span class="o">=</span> <span class="n">y_shifts</span>

        <span class="c1"># plot </span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>    
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figheight</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizey</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">set_figwidth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">figsizex</span><span class="p">)</span> 
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_height</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="c1"># axis.invert_yaxis()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;height [nm]&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;realinging&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">align_points</span><span class="p">,</span> <span class="p">[</span><span class="n">element</span> <span class="o">+</span> <span class="n">lower</span> <span class="o">+</span> <span class="p">(</span><span class="n">upper</span><span class="o">-</span><span class="n">lower</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_shifts</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">hlines</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_y_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lower_y_bound</span><span class="p">],</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">XRes</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># reinitialize the instance data to fit the new bigger arrays</span>
        <span class="n">min_shift</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">))</span>
        <span class="n">max_shift</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">y_shifts</span><span class="p">))</span>
        <span class="n">new_YRes</span> <span class="o">=</span> <span class="n">YRes</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">min_shift</span><span class="o">-</span><span class="n">max_shift</span><span class="p">))</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)):</span>
            <span class="n">shifted_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_data</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_shifts</span><span class="p">)</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shifted_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_shifted&#39;</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.cut_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.cut_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autocut</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coords</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reset_mask</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function cuts the specified channels to the specified region. If no coordinates are specified you will be prompted with a window to select an area.</span>
<span class="sd">        If you created a mask previously for this instance the old mask will be reused! Otherwise you should manually change the reset_mask parameter to True.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): List of channels you want to cut. If not specified all channels in memory will be cut. Defaults to None.</span>
<span class="sd">            preview_channel (str, optional): The channel to display for the area selection. If not specified the height channel will be used if it is in memory,</span>
<span class="sd">                otherwise the first of the specified channels will be used. Defaults to None</span>
<span class="sd">            autocut (bool, optional): If set to &#39;True&#39; the program will automatically try to remove zero lines and columns, which can result from masking.</span>
<span class="sd">            coords (list, optional): If you already now the coordinates ([[x1,y1], [x2,y2], [x3,y3], [x4,y4]]) to which you want to cut your data. Defaults to None.</span>
<span class="sd">            reset_mask (bool, optional): If you dont want to reuse an old mask set to True. Defaults to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="c1"># if nothing is specified, the cut will be applied to all channels in memory!</span>
        <span class="c1"># check if height channel in channels and apply mask to it, until now it has not been masked in order to show the mask in the image</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">):</span>
                <span class="n">preview_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preview_channel</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># apply the already existing mask if possible.  </span>
        <span class="k">if</span> <span class="n">reset_mask</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>  
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">)</span>
                    <span class="c1"># self.channels[index] += &#39;_reduced&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;There does not seem to be an old mask... &#39;</span><span class="p">)</span>
        <span class="c1"># generate new mask by selecting a region in the preview channel</span>
        <span class="k">elif</span> <span class="n">autocut</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">)]</span>
            <span class="c1"># get the coordinates of the selection rectangle</span>
            <span class="k">if</span> <span class="n">coords</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="n">select_rectangle</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;cut_coords&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
            <span class="c1"># use the selection to create a mask and multiply to all channels, then apply auto_cut function</span>
            <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres</span><span class="p">,</span> <span class="n">xres</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="c1"># set all values outside of the mask to zero and then cut all zero away from the outside with _auto_cut_channels(channels)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_array</span><span class="p">)</span>
        <span class="c1"># apply the auto cut function to remove masked areas around the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_cut_channels</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_auto_cut_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function automatically cuts away all rows and lines which are only filled with zeros.</span>
<span class="sd">        This function applies to all channels in memory.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        
        <span class="c1"># get the new size of the reduced channels</span>
        <span class="n">reduced_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_cut_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="c1"># get the old size of the data</span>
            <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="n">xreal</span><span class="p">,</span> <span class="n">yreal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_cut_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">xres_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">yres_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">xreal_new</span> <span class="o">=</span> <span class="n">xreal</span><span class="o">*</span><span class="n">xres_new</span><span class="o">/</span><span class="n">xres</span>
            <span class="n">yreal_new</span> <span class="o">=</span> <span class="n">yreal</span><span class="o">*</span><span class="n">yres_new</span><span class="o">/</span><span class="n">yres</span>
            <span class="c1"># save new resolution and scan area in channel tag dict:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">xres_new</span><span class="p">,</span> <span class="n">yres_new</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">xreal_new</span><span class="p">,</span> <span class="n">yreal_new</span><span class="p">])</span>
            <span class="c1"># add new appendix to channel</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;_reduced&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;cut&#39;</span><span class="p">,</span> <span class="s1">&#39;autocut&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_auto_cut_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function cuts the data and removes zero values from the outside.&quot;&quot;&quot;</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># find empty columns and rows to delete:</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
            <span class="n">add_to_columns</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">add_to_columns</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">add_to_columns</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="n">add_to_rows</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">add_to_rows</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">add_to_rows</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># create reduced data array</span>
        <span class="n">x_reduced</span> <span class="o">=</span> <span class="n">xres</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">y_reduced</span> <span class="o">=</span> <span class="n">yres</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
        <span class="n">data_reduced</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">y_reduced</span><span class="p">,</span> <span class="n">x_reduced</span><span class="p">))</span>
        <span class="c1"># iterate through all pixels and check if they are in rows and columns, then add them to the reduced data array</span>
        <span class="n">count_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">count_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                        <span class="n">data_reduced</span><span class="p">[</span><span class="n">count_y</span><span class="p">][</span><span class="n">count_x</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> 
                        <span class="n">count_x</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">count_x</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">count_y</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">data_reduced</span>

<div class="viewcode-block" id="SnomMeasurement.scalebar">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.scalebar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scalebar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="p">[],</span> <span class="n">units</span><span class="o">=</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="s2">&quot;si-length&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">length_fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">height_fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width_fraction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">border_pad</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">box_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">box_alpha</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">label_loc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">font_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scale_formatter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fixed_units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">animated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds a scalebar to all specified channels.</span>
<span class="sd">        Args:</span>
<span class="sd">            channels (list): List of channels the scalebar should be added to.</span>
<span class="sd">            various definitions for the scalebar, please look up &#39;matplotlib_scalebar.scalebar&#39; for more information</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="c1"># scalebar = ScaleBar(dx, units, dimension, label, length_fraction, height_fraction, width_fraction,</span>
            <span class="c1"># location, loc, pad, border_pad, sep, frameon, color, box_color, box_alpha, scale_loc,</span>
            <span class="c1"># label_loc, font_properties, label_formatter, scale_formatter, fixed_value, fixed_units, animated, rotation)</span>
        
        
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="n">pixel_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">XReal</span><span class="o">/</span><span class="p">(</span><span class="n">XRes</span><span class="p">)</span>
            <span class="n">scalebar_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">dx</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">length_fraction</span><span class="p">,</span> <span class="n">height_fraction</span><span class="p">,</span> <span class="n">width_fraction</span><span class="p">,</span>
                            <span class="n">location</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">border_pad</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">frameon</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">box_color</span><span class="p">,</span> <span class="n">box_alpha</span><span class="p">,</span> <span class="n">scale_loc</span><span class="p">,</span>
                            <span class="n">label_loc</span><span class="p">,</span> <span class="n">font_properties</span><span class="p">,</span> <span class="n">label_formatter</span><span class="p">,</span> <span class="n">scale_formatter</span><span class="p">,</span> <span class="n">fixed_value</span><span class="p">,</span> <span class="n">fixed_units</span><span class="p">,</span> <span class="n">animated</span><span class="p">,</span> <span class="n">rotation</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">channel</span><span class="p">,</span> <span class="n">scalebar_var</span><span class="p">])</span>                
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scalebar_channels</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">channel</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>                
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="SnomMeasurement.rotate_90_deg">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.rotate_90_deg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_90_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orientation</span><span class="p">:</span><span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will rotate all data in memory by 90 degrees.</span>

<span class="sd">        Args:</span>
<span class="sd">            orientation (str, optional): rotate clockwise (&#39;right&#39;) or counter clockwise (&#39;left&#39;). Defaults to &#39;right&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;rotation&#39;</span><span class="p">,</span> <span class="o">+</span><span class="mi">90</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;rotation&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">)</span>
        <span class="c1">#rotate data:</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># initialize data array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="c1"># flip pixelarea and scanarea as well</span>
            <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">YReal</span><span class="p">,</span> <span class="n">XReal</span><span class="p">])</span>
            <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">(</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">))</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_positions_from_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_phase</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_amplitude</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_height</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coordinates</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orientation</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_plot_profile_lines</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Please select one or more points to continue.&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span> <span class="c1">#klicker returns a dictionary for the events</span>
        <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">klick_coordinates</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span> <span class="n">orientation</span><span class="p">:</span><span class="n">Definitions</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">all_profiles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">:</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                        <span class="n">value</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">/</span><span class="n">width</span>
                    <span class="n">profile</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">horizontal</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                        <span class="n">value</span> <span class="o">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">/</span><span class="n">width</span>
                    <span class="n">profile</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">all_profiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_profiles</span>

<div class="viewcode-block" id="SnomMeasurement.select_profile">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.select_profile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientation</span><span class="p">:</span><span class="n">Definitions</span><span class="o">=</span><span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">phase_orientation</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function lets the user select a profile with given width in pixels and displays the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            profile_channel (str): channel to use for profile data extraction</span>
<span class="sd">            preview_channel (str, optional): channel to preview the profile positions. If not specified the height channel will be used for that. Defaults to None.</span>
<span class="sd">            orientation (Definitions, optional): profiles can be horizontal or vertical. Defaults to Definitions.vertical.</span>
<span class="sd">            width (int, optional): width of the profile in pixels, will calculate the mean. Defaults to 10.</span>
<span class="sd">            phase_orientation (int, optional): only relevant for phase profiles. Necessary for the flattening to work properly. Defaults to 1.</span>
<span class="sd">            coordinates (list, optional): if you already now the position of your profile you can also specify the coordinates and skip the selection. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">preview_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
        <span class="k">if</span> <span class="n">coordinates</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">previewdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">)]</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_positions_from_plot</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">)</span>

        <span class="n">profiledata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">)]</span>

        <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_phase</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">profiledata</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">profiledata</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">horizontal</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">ycoord</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">profiledata</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;You chose the following line profiles&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="c1"># it would be nice to be able to add non pcolormesh plots to the subplotslist</span>
        <span class="c1"># self.all_subplots.append()</span>

        <span class="n">profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profile</span><span class="p">(</span><span class="n">profiledata</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">:</span>
            <span class="n">xvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase profiles&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">flattened_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">flatten_phase_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">phase_orientation</span><span class="p">)</span> <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="n">flattened_profiles</span><span class="p">:</span>
            <span class="n">xvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">profile</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Flattened phase profiles&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">difference_profile</span> <span class="o">=</span> <span class="n">phase_analysis</span><span class="o">.</span><span class="n">get_profile_difference</span><span class="p">(</span><span class="n">profiles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">profiles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># difference_profile = get_profile_difference(flattened_profiles[0], flattened_profiles[1])</span>
        <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="n">xreal</span><span class="p">,</span> <span class="n">yreal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="n">pixel_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span>
        <span class="n">xvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">yreal</span><span class="o">/</span><span class="n">yres</span><span class="o">/</span><span class="n">pixel_scaling</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="o">*</span><span class="n">pixel_scaling</span><span class="p">)]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">difference_profile</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Y [m]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Phase difference&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase difference&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_data_and_profile_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_phase</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_amplitude</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_height</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_profile_lines</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;You chose the following line profiles&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_plot_profile_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">):</span>
        <span class="n">xcoord</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>
        <span class="n">ycoord</span> <span class="o">=</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xcoord</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">horizontal</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">ycoord</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_profiles_Coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile_channel</span><span class="p">,</span> <span class="n">profiledata</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">redo</span><span class="p">:</span><span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">redo_coordinates</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">redo</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_positions_from_plot</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">display_coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">redo_coordinates</span><span class="p">]</span><span class="c1"># remove coordinates to redo and plot the other ones while selecton is active</span>
            <span class="n">redone_coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_positions_from_plot</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">,</span> <span class="n">display_coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">redo_coordinates</span><span class="p">:</span>
                <span class="n">coordinates</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">redone_coordinates</span><span class="p">[</span><span class="n">count</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_data_and_profile_pos</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">,</span> <span class="n">profiledata</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Are you satisfied with the profile positions? Or would you like to change one ore more profile positions?&#39;</span><span class="p">)</span>
        <span class="n">user_input_bool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span> 
        <span class="k">if</span> <span class="n">user_input_bool</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input</span><span class="p">(</span><span class="s1">&#39;Please enter the indices of the profiles you like to redo, separated by a space character e.g. (0 1 3 11 ...)</span><span class="se">\n</span><span class="s1">Your indices: &#39;</span><span class="p">)</span> 
            <span class="n">redo_coordinates</span> <span class="o">=</span> <span class="n">user_input</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="n">redo_coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">redo_coordinates</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;coordinates to redo: &#39;</span><span class="p">,</span> <span class="n">redo_coordinates</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please select the new positons only for the indices you selected and in the same ordering, those were: &#39;</span><span class="p">,</span> <span class="n">redo_coordinates</span><span class="p">)</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profiles_Coordinates</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">,</span> <span class="n">profiledata</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">redo</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">coordinates</span><span class="o">=</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">redo_coordinates</span><span class="o">=</span><span class="n">redo_coordinates</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">coordinates</span>

<div class="viewcode-block" id="SnomMeasurement.select_profiles">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.select_profiles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientation</span><span class="p">:</span><span class="n">Definitions</span><span class="o">=</span><span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function lets the user select a profile with given width in pixels and displays the data.</span>

<span class="sd">        Args:</span>
<span class="sd">            profile_channel (str): channel to use for profile data extraction</span>
<span class="sd">            preview_channel (str, optional): channel to preview the profile positions. If not specified the height channel will be used for that. Defaults to None.</span>
<span class="sd">            orientation (Definitions, optional): profiles can be horizontal or vertical. Defaults to Definitions.vertical.</span>
<span class="sd">            width (int, optional): width of the profile in pixels, will calculate the mean. Defaults to 10.</span>
<span class="sd">            coordinates (list, optional): if you already now the position of your profile you can also specify the coordinates and skip the selection. Defaults to None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">preview_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">and</span> <span class="n">profile_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels for preview and the profiles were not found in the memory, they will be loaded automatically.</span><span class="se">\n</span><span class="s1">Be aware that all prior modifications will get deleted.&#39;</span><span class="p">)</span>  
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">profile_channel</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">])</span><span class="c1">#this will negate any modifications done prior like blurr...</span>
        <span class="n">profiledata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">)]</span>
        <span class="n">previewdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">coordinates</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profiles_Coordinates</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">,</span> <span class="n">profiledata</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The final profiles are shown in this plot.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_data_and_profile_pos</span><span class="p">(</span><span class="n">profile_channel</span><span class="p">,</span> <span class="n">profiledata</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="c1"># get the profile data and save to class variables</span>
        <span class="c1"># additional infos are also stored and can be used by plotting and analysis functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profile</span><span class="p">(</span><span class="n">profiledata</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span> <span class="o">=</span> <span class="n">profile_channel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_orientation</span> <span class="o">=</span> <span class="n">orientation</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span></div>


<div class="viewcode-block" id="SnomMeasurement.select_profiles_SSH">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.select_profiles_SSH">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">select_profiles_SSH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profile_channel_amp</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">profile_channel_phase</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orientation</span><span class="p">:</span><span class="n">Definitions</span><span class="o">=</span><span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">,</span> <span class="n">width_amp</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">width_phase</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function lets the user select a profile with given width in pixels and displays the data.</span>
<span class="sd">        Specific function for ssh model measurements. This will create a plot of field per waveguide index for the topological array.</span>
<span class="sd">        The field is calculated from the amplitude profiles times the cosine of the phasedifference to the central waveguide. </span>

<span class="sd">        Args:</span>
<span class="sd">            profile_channel_amp (str): amplitude channel for profile data</span>
<span class="sd">            profile_channel_phase (str): phase channel for profile data</span>
<span class="sd">            preview_channel (str, optional): channel to preview the profile positions. If not specified the height channel will be used for that. Defaults to None.</span>
<span class="sd">            orientation (Definitions, optional): profiles can be horizontal or vertical. Defaults to Definitions.vertical.</span>
<span class="sd">            width_amp (int, optional): width of the amplitude profile in pixels. Defaults to 10.</span>
<span class="sd">            width_phase (int, optional): width of the phase profile in pixels. Defaults to 1.</span>
<span class="sd">            coordinates (list, optional): if you already now the position of your profile you can also specify the coordinates and skip the selection. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">preview_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span>
        <span class="k">if</span> <span class="n">preview_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">profile_channel_amp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">profile_channel_phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels for preview and the profiles were not found in the memory, they will be loaded automatically.</span><span class="se">\n</span><span class="s1">Be aware that all prior modifications will get deleted.&#39;</span><span class="p">)</span>  
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">profile_channel_amp</span><span class="p">,</span> <span class="n">profile_channel_phase</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">])</span><span class="c1">#this will negate any modifications done prior like blurr...</span>
        <span class="n">profiledata_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel_amp</span><span class="p">)]</span>
        <span class="n">profiledata_phase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile_channel_phase</span><span class="p">)]</span>
        <span class="n">previewdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">preview_channel</span><span class="p">)]</span>
        <span class="c1"># get the profile coordinates</span>
        <span class="k">if</span> <span class="n">coordinates</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profiles_Coordinates</span><span class="p">(</span><span class="n">profile_channel_phase</span><span class="p">,</span> <span class="n">profiledata_phase</span><span class="p">,</span> <span class="n">preview_channel</span><span class="p">,</span> <span class="n">previewdata</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;You selected the following coordinates: &#39;</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The final profiles are shown in this plot.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_data_and_profile_pos</span><span class="p">(</span><span class="n">profile_channel_phase</span><span class="p">,</span> <span class="n">profiledata_phase</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plot_data_and_profile_pos</span><span class="p">(</span><span class="n">profile_channel_amp</span><span class="p">,</span> <span class="n">profiledata_amp</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span> <span class="o">=</span> <span class="n">profile_channel_phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">profile_orientation</span> <span class="o">=</span> <span class="n">orientation</span>

        <span class="c1"># get the profile data for amp and phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profile</span><span class="p">(</span><span class="n">profiledata_phase</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">width_phase</span><span class="p">)</span>
        <span class="c1"># test:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span><span class="p">[</span><span class="mi">16</span><span class="p">]])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">amp_profiles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_profile</span><span class="p">(</span><span class="n">profiledata_amp</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">width_amp</span><span class="p">)</span>
        <span class="n">mean_amp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">amp</span><span class="p">)</span> <span class="k">for</span> <span class="n">amp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_profiles</span><span class="p">]</span>
        <span class="n">reference_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># phase_difference_profiles = [Phase_Analysis.get_profile_difference(self.phase_profiles[reference_index], self.phase_profiles[i]) for i in range(len(self.phase_profiles))]</span>
        <span class="n">flattened_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">flatten_phase_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">(</span><span class="n">flattened_profiles</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Flattened phase profiles&#39;</span><span class="p">)</span> <span class="c1"># display the flattened profiles</span>
        <span class="c1"># phase_difference_profiles = [Phase_Analysis.get_profile_difference_2(self.phase_profiles[reference_index], self.phase_profiles[i]) for i in range(len(self.phase_profiles))]</span>
        <span class="n">phase_difference_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">get_profile_difference_2</span><span class="p">(</span><span class="n">flattened_profiles</span><span class="p">[</span><span class="n">reference_index</span><span class="p">],</span> <span class="n">flattened_profiles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flattened_profiles</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">(</span><span class="n">phase_difference_profiles</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Phase difference to center wg&#39;</span><span class="p">)</span> <span class="c1"># display the phase difference profiles, no jumps close to 2 pi should occure or the average will lead to false values!</span>
        <span class="c1"># mean_phase_differences = [np.mean(diff) for diff in phase_difference_profiles]# todo this does not work!</span>
        <span class="n">mean_phase_differences</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">phase_difference_profiles</span><span class="p">]</span><span class="c1"># todo this does not work!</span>
        <span class="n">real_per_wg_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">mean_amp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">mean_phase_differences</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_profiles</span><span class="p">))]</span>
        <span class="n">intensity_per_wg_index</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">real_per_wg_index</span><span class="p">]</span>
        <span class="n">wg_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">reference_index</span><span class="p">,</span> <span class="n">reference_index</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(wg_indices)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wg_indices</span><span class="p">,</span> <span class="n">real_per_wg_index</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Real per wg index&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=-</span><span class="mi">10</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;E$_z$ [arb.u]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Waveguide index&#39;</span><span class="p">)</span>
        <span class="c1"># plt.ylim([-0.04,0.04])</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">reference_index</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

        
    <span class="k">def</span><span class="w"> </span><span class="nf">_display_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">,</span> <span class="n">ylabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">horizontal</span><span class="p">:</span>
            <span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="n">x_center_pos</span><span class="p">,</span> <span class="n">y_center_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">)</span>
            <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="n">xvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_center_pos</span> <span class="o">-</span> <span class="n">xrange</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="n">xrange</span><span class="o">/</span><span class="n">xres</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">)]</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;X [m]&#39;</span>
            <span class="k">if</span> <span class="n">title</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Horizontal profiles of channel &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_orientation</span> <span class="o">==</span> <span class="n">Definitions</span><span class="o">.</span><span class="n">vertical</span><span class="p">:</span>
            <span class="n">xrange</span><span class="p">,</span> <span class="n">yrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
            <span class="n">x_center_pos</span><span class="p">,</span> <span class="n">y_center_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANNERCENTERPOSITION</span><span class="p">)</span>
            <span class="n">xres</span><span class="p">,</span> <span class="n">yres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">),</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="n">xvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_center_pos</span> <span class="o">-</span> <span class="n">yrange</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">yrange</span><span class="o">/</span><span class="n">yres</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">)]</span>
            <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;Y [m]&#39;</span>
            <span class="k">if</span> <span class="n">title</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Vertical profiles of channel &#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span>
        <span class="c1"># find out y label:</span>
        <span class="k">if</span> <span class="n">ylabel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">:</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Phase&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">:</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Amplitude [arb.u.]&#39;</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profile_channel</span><span class="p">:</span>
                <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;Height [nm]&#39;</span>
        <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="n">profiles</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">profiles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">labels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Profile index: </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">profile</span><span class="p">,</span> <span class="n">linestyle</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">labels</span><span class="p">[</span><span class="n">profiles</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">profile</span><span class="p">)])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<div class="viewcode-block" id="SnomMeasurement.display_profiles">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_profiles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_profiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will display all current profiles from memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            ylabel (str, optional): label of the y axis. The x axis label is in m per default. Defaults to None.</span>
<span class="sd">            labels (list, optional): the description of the profiles. Will be displayed in the legend. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.display_flattened_profile">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_flattened_profile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_flattened_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phase_orientation</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will flatten all profiles in memory and display them. Only useful for phase profiles!</span>

<span class="sd">        Args:</span>
<span class="sd">            phase_orientation (int): direction of the phase, must be &#39;1&#39; or &#39;-1&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flattened_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">flatten_phase_profile</span><span class="p">(</span><span class="n">profile</span><span class="p">,</span> <span class="n">phase_orientation</span><span class="p">)</span> <span class="k">for</span> <span class="n">profile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">(</span><span class="n">flattened_profiles</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.display_phase_difference">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.display_phase_difference">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_phase_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will calculate the phase difference of all profiles relative to the profile specified by the reference index.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference_index (int): index of the reference profile. Basically the nth-1 selected profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">difference_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">get_profile_difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">[</span><span class="n">reference_index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">profiles</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">reference_index</span><span class="p">]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Wg index &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">difference_profiles</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_profile</span><span class="p">(</span><span class="n">difference_profiles</span><span class="p">,</span> <span class="s1">&#39;Phase difference&#39;</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_mean_phase_difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">profiles</span><span class="p">,</span> <span class="n">reference_index</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span>
        <span class="n">difference_profiles</span> <span class="o">=</span> <span class="p">[</span><span class="n">phase_analysis</span><span class="o">.</span><span class="n">get_profile_difference</span><span class="p">(</span><span class="n">profiles</span><span class="p">[</span><span class="n">reference_index</span><span class="p">],</span> <span class="n">profiles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">profiles</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">reference_index</span><span class="p">]</span>
        <span class="n">mean_differences</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="k">for</span> <span class="n">diff</span> <span class="ow">in</span> <span class="n">difference_profiles</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">mean_differences</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_scale_data_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
        <span class="n">XRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">YRes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="o">*</span><span class="n">scale_y</span><span class="p">,</span> <span class="n">XRes</span><span class="o">*</span><span class="n">scale_x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scale_y</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">scale_x</span><span class="p">):</span>
                        <span class="n">new_data</span><span class="p">[</span><span class="n">y</span><span class="o">*</span><span class="n">scale_y</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="n">x</span><span class="o">*</span><span class="n">scale_x</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_data</span>

<div class="viewcode-block" id="SnomMeasurement.quadratic_pixels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.quadratic_pixels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">quadratic_pixels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function scales the data such that each pixel is quadratic, eg. the physical dimensions are equal.</span>
<span class="sd">        This is important because the pixels will be set to quadratic in the plotting function.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            channels [list]: list of channels the scaling should be applied to. If not specified the scaling will be applied to all channels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;quadratic_pixels&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
                <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
                <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">XReal</span><span class="o">/</span><span class="n">XRes</span> <span class="o">*</span><span class="mi">1000000000</span><span class="p">)</span> <span class="c1"># pixel size in nm</span>
                <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">YReal</span><span class="o">/</span><span class="n">YRes</span> <span class="o">*</span><span class="mi">1000000000</span><span class="p">)</span>
                <span class="n">scale_x</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">scale_y</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">pixel_size_x</span> <span class="o">&lt;</span> <span class="n">pixel_size_y</span><span class="p">:</span>
                    <span class="n">scale_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pixel_size_y</span><span class="o">/</span><span class="n">pixel_size_x</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">pixel_size_x</span> <span class="o">&gt;</span> <span class="n">pixel_size_y</span><span class="p">:</span>
                    <span class="n">scale_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pixel_size_x</span><span class="o">/</span><span class="n">pixel_size_y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pixel_size_x</span><span class="o">/</span><span class="n">scale_x</span> <span class="o">!=</span> <span class="n">pixel_size_y</span><span class="o">/</span><span class="n">scale_y</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The pixel size does not fit perfectly, you probably chose weired resolution values. You should probably not use this function then...&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_data_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XRes</span><span class="o">*</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">YRes</span><span class="o">*</span><span class="n">scale_y</span><span class="p">])</span></div>


<div class="viewcode-block" id="SnomMeasurement.overlay_forward_and_backward_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.overlay_forward_and_backward_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlay_forward_and_backward_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_channel_forward</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function is ment to overlay the backwards and forwards version of the specified channels.</span>
<span class="sd">        You should only specify the forward version of the channels you want to overlay. The function will create a mean version</span>
<span class="sd">        which can then be displayed and saved. Note that the new version will be larger then the previous ones.</span>

<span class="sd">        Args:</span>
<span class="sd">            height_channel_forward (str): usual corrected height channel</span>
<span class="sd">            height_channel_backward (str): backwards height channel</span>
<span class="sd">            channels (list, optional): a list of all channels to be overlain. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">all_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">all_channels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="o">+</span> <span class="n">channel</span><span class="p">])</span>
        <span class="n">all_channels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">height_channel_forward</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">all_channels</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_min_to_zero</span><span class="p">([</span><span class="n">height_channel_forward</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">])</span>
        
        <span class="c1">#scale and blurr channels for better overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">()</span>
        <span class="c1"># self.gauss_filter_channels_complex()</span>

        <span class="n">height_data_forward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">height_channel_forward</span><span class="p">)]</span>
        <span class="n">height_data_backward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">height_channel_backward</span><span class="p">)]</span>
        
        <span class="c1">#gauss blurr the data used for the alignment, so it might be a litte more precise</span>
        <span class="n">height_channel_forward_blurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">height_data_forward</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">height_channel_backward_blurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">height_data_backward</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># array_1 = height_data_forward[0]</span>
        <span class="c1"># array_2 = height_data_backward[0]</span>

<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        mean_deviation_array = realign.Calculate_Squared_Deviation(array_1, array_2)</span>
<span class="sd">        mean_deviation = np.mean(mean_deviation_array)</span>
<span class="sd">        x = range(len(array_1))</span>
<span class="sd">        plt.plot(x, array_1, label=&#39;array_2&#39;)</span>
<span class="sd">        plt.plot(x, array_2, label=&#39;array_1&#39;)</span>
<span class="sd">        plt.plot(x, mean_deviation_array, label=&quot;Mean deviation_array&quot;)</span>
<span class="sd">        plt.hlines(mean_deviation, label=&quot;Mean deviation&quot;, xmin=0, xmax=len(array_1))</span>
<span class="sd">        plt.legend()</span>
<span class="sd">        plt.show()</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># try to optimize by shifting second array and minimizing mean deviation</span>
        <span class="n">pixel_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">pixel_scaling</span> <span class="c1">#maximum iterations, scaled if pixelnumber was increased</span>

        <span class="c1"># realign.minimize_deviation_1d(array_1, array_2, n_tries=N)</span>
        <span class="c1"># realign.Minimize_Deviation_2D(height_data_forward, height_data_backward, n_tries=N)</span>

        <span class="c1"># get the index which minimized the deviation of the height channels</span>
        <span class="c1"># index = realign.Minimize_Deviation_2D(height_data_forward, height_data_backward, N, False)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">realign</span><span class="o">.</span><span class="n">Minimize_Deviation_2D</span><span class="p">(</span><span class="n">height_channel_forward_blurr</span><span class="p">,</span> <span class="n">height_channel_backward_blurr</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="c1"># self.all_data[self.channels.index(height_channel_forward)], self.all_data[self.channels.index(height_channel_backward)] = realign.Shift_Array_2D_by_Index(height_data_forward, height_data_backward, index)</span>


        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="c1">#test:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="c1"># get current res and size and add the additional res and size due to addition of zeros while shifting</span>
                    <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
                    <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
                    <span class="n">XRes_new</span> <span class="o">=</span> <span class="n">XRes</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="c1"># absolute value? index can be negative, but resolution can only increase, same for real dimensions</span>
                    <span class="n">XReal_new</span> <span class="o">=</span> <span class="n">XReal</span> <span class="o">+</span> <span class="n">XReal</span><span class="o">/</span><span class="n">XRes</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    
                    <span class="c1"># create channel_dict for new mean data </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>

                    <span class="c1"># also create data dict entry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>

                    <span class="c1"># add new channel to channels</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XRes_new</span><span class="p">,</span> <span class="n">YRes</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XReal_new</span><span class="p">,</span> <span class="n">YReal</span><span class="p">])</span>

                    <span class="c1">#test realign (per scan) based on minimization of differences </span>
                    <span class="c1">#not usable right now, drift compensation might lead to differently sized data</span>
                    <span class="c1"># self.all_data[self.channels.index(height_channel_forward)] = realign.Minimize_Drift(self.all_data[self.channels.index(height_channel_forward)], display=False)</span>
                    <span class="c1"># self.all_data[self.channels.index(height_channel_backward)] = realign.Minimize_Drift(self.all_data[self.channels.index(height_channel_backward)])</span>

                    <span class="c1"># shift the data of the forward and backwards channel to match</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="n">realign</span><span class="o">.</span><span class="n">Shift_Array_2D_by_Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)],</span> <span class="n">index</span><span class="p">)</span>
        

                    <span class="c1"># create mean data and append to all_data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">realign</span><span class="o">.</span><span class="n">Create_Mean_Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># get current res and size and add the additional res and size due to addition of zeros while shifting</span>
                    <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
                    <span class="n">XReal</span><span class="p">,</span> <span class="n">YReal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
                    <span class="n">XRes_new</span> <span class="o">=</span> <span class="n">XRes</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="c1"># absolute value? index can be negative, but resolution can only increase, same for real dimensions</span>
                    <span class="n">XReal_new</span> <span class="o">=</span> <span class="n">XReal</span> <span class="o">+</span> <span class="n">XReal</span><span class="o">/</span><span class="n">XRes</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    
                    <span class="c1"># create channel_dict for new mean data </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>

                    <span class="c1"># also create data dict entry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>

                    <span class="c1"># add new channel to channels</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>
                    
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XRes_new</span><span class="p">,</span> <span class="n">YRes</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_channel_tag_dict_value</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">,</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XReal_new</span><span class="p">,</span> <span class="n">YReal</span><span class="p">])</span>

                    <span class="c1">#test realign (per scan) based on minimization of differences </span>
                    <span class="c1"># self.all_data[self.channels.index(channel)] = realign.Minimize_Drift(self.all_data[self.channels.index(channel)], display=False)</span>
                    <span class="c1"># self.all_data[self.channels.index(self.backwards_indicator+ channel)] = realign.Minimize_Drift(self.all_data[self.channels.index(self.backwards_indicator+ channel)])</span>

                    <span class="c1"># shift the data of the forward and backwards channel to match</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="n">realign</span><span class="o">.</span><span class="n">Shift_Array_2D_by_Index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)],</span> <span class="n">index</span><span class="p">)</span>

                    <span class="c1"># create mean data and append to all_data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">realign</span><span class="o">.</span><span class="n">Create_Mean_Array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)]))</span>

        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.overlay_forward_and_backward_channels_V2">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.overlay_forward_and_backward_channels_V2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlay_forward_and_backward_channels_V2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">height_channel_forward</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Caution! This variant is ment to keep the scan size identical!</span>

<span class="sd">        This function is ment to overlay the backwards and forwards version of the specified channels.</span>
<span class="sd">        You should only specify the forward version of the channels you want to overlay. The function will create a mean version</span>
<span class="sd">        which can then be displayed and saved.</span>

<span class="sd">        Args:</span>
<span class="sd">            height_channel_forward (str): Usual corrected height channel</span>
<span class="sd">            height_channel_backward (str): Backwards height channel</span>
<span class="sd">            channels (list, optional): List of all channels to be overlain. Only specify the forward direction. Defaults to None.</span>
<span class="sd">            If not specified only the amp channels and the height channel will be overlaid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">]</span>
            <span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">)</span>
        <span class="n">all_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">all_channels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="o">+</span> <span class="n">channel</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">height_channel_forward</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">all_channels</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">height_channel_forward</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">(</span><span class="n">all_channels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_min_to_zero</span><span class="p">([</span><span class="n">height_channel_forward</span><span class="p">,</span> <span class="n">height_channel_backward</span><span class="p">])</span>
        
        <span class="c1">#scale channels for more precise overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_channels</span><span class="p">()</span>
        <span class="n">height_data_forward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">height_channel_forward</span><span class="p">)]</span>
        <span class="n">height_data_backward</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">height_channel_backward</span><span class="p">)]</span>
        
        <span class="c1">#gauss blurr the data used for the alignment, so it might be a litte more precise</span>
        <span class="n">height_channel_forward_blurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">height_data_forward</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">height_channel_backward_blurr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_blurr_data</span><span class="p">(</span><span class="n">height_data_backward</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># try to optimize by shifting second array and minimizing mean deviation</span>
        <span class="n">pixel_scaling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_channel_tag_dict_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELSCALING</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="n">pixel_scaling</span> <span class="c1">#maximum iterations, scaled if pixelnumber was increased</span>

        <span class="c1"># get the index which minimized the deviation of the height channels</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">realign</span><span class="o">.</span><span class="n">Minimize_Deviation_2D</span><span class="p">(</span><span class="n">height_channel_forward_blurr</span><span class="p">,</span> <span class="n">height_channel_backward_blurr</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="c1"># create channel_dict for new mean data </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>

                    <span class="c1"># also create data dict entry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>

                    <span class="c1"># add new channel to channels</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>
        
                    <span class="c1"># create mean data and append to all_data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">realign</span><span class="o">.</span><span class="n">Create_Mean_Array_V2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)],</span> <span class="n">index</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># create channel_dict for new mean data </span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)])</span>

                    <span class="c1"># also create data dict entry</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>

                    <span class="c1"># add new channel to channels</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_overlain&#39;</span><span class="p">)</span>
                    
                    <span class="c1"># create mean data and append to all_data</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">realign</span><span class="o">.</span><span class="n">Create_Mean_Array_V2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span><span class="o">+</span> <span class="n">channel</span><span class="p">)],</span> <span class="n">index</span><span class="p">))</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.manually_create_complex_channel">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.manually_create_complex_channel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">manually_create_complex_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amp_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">complex_type</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will manually create a realpart channel depending on the amp and phase channel you give.</span>
<span class="sd">        The channels don&#39;t have to be in memory. If they are not they will be loaded but not added to memory, only the realpart will be added.</span>
<span class="sd">        Carful, only for expert users!</span>

<span class="sd">        Args:</span>
<span class="sd">            amp_channel (str): Amplitude channel.</span>
<span class="sd">            phase_channel (str): Phase channel.</span>
<span class="sd">            complex_type (str, optional): Type of the data you want to create. &#39;real&#39; creates the realpart, &#39;imag&#39; the imaginary part.</span>
<span class="sd">                If not specified both will be created. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if channels match, check for data type (amp, phase) and demodulation order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">amp_channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified channels are not specified as needed!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">demodulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_demodulation_num</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">demodulation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels you specified are not from the same demodulation order!</span><span class="se">\n</span><span class="s1">Proceeding anyways...&#39;</span><span class="p">)</span>
        <span class="c1"># check if channels are in memory, if not load the data</span>
        <span class="k">if</span> <span class="n">amp_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">amp_data</span><span class="p">,</span> <span class="n">amp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
            <span class="n">amp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">phase_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">phase_data</span><span class="p">,</span> <span class="n">phase_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
            <span class="n">phase_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="c1"># check if size is identical:</span>
        <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span> <span class="o">=</span> <span class="n">amp_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="n">xres_phase</span><span class="p">,</span> <span class="n">yres_phase</span> <span class="o">=</span> <span class="n">phase_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xres_amp</span> <span class="o">!=</span> <span class="n">xres_phase</span> <span class="ow">or</span> <span class="n">yres_amp</span> <span class="o">!=</span> <span class="n">yres_phase</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The data of the specified channels has different resolution!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        
        <span class="c1"># create complex data:</span>
        <span class="n">real_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres_amp</span><span class="p">,</span> <span class="n">xres_amp</span><span class="p">))</span>
        <span class="n">imag_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yres_amp</span><span class="p">,</span> <span class="n">xres_amp</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres_amp</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres_amp</span><span class="p">):</span>
                <span class="n">real_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">])</span>
                <span class="n">imag_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">])</span>
        <span class="c1"># create realpart and imaginary part channel and dict and add to memory</span>
        <span class="n">real_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span>
        <span class="n">imag_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span>
        <span class="n">real_channel_dict</span> <span class="o">=</span> <span class="n">amp_dict</span>
        <span class="n">imag_channel_dict</span> <span class="o">=</span> <span class="n">amp_dict</span>

        <span class="k">if</span> <span class="n">complex_type</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">complex_type</span> <span class="o">==</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">complex_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># just save both</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_channel</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel_dict</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">imag_channel</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="SnomMeasurement.create_gif_old">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.create_gif_old">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_gif_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amp_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">framenumbers</span><span class="o">=</span><span class="n">frames</span>
        <span class="n">Duration</span><span class="o">=</span><span class="mi">1000</span><span class="o">/</span><span class="n">fps</span> <span class="c1"># in ms</span>

        <span class="n">realcolorpalette</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1"># old color palette</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">):</span>
            <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">127</span><span class="p">):</span> <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">255</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">255</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">amp_channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified channels are not specified as needed!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># demodulation = amp_channel[1:2]</span>
        <span class="n">demodulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_demodulation_num</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;demodulation: &#39;</span><span class="p">,</span> <span class="n">demodulation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">demodulation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels you specified are not from the same demodulation order!</span><span class="se">\n</span><span class="s1">Proceeding anyways...&#39;</span><span class="p">)</span>
        <span class="c1"># check if channels are in memory, if not load the data</span>
        <span class="k">if</span> <span class="n">amp_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">phase_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels for amplitude or phase were not found in the memory, they will be loaded automatically.</span><span class="se">\n</span><span class="s1">Be aware that all prior modifications will get deleted.&#39;</span><span class="p">)</span>
            <span class="c1"># reload all channels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">amp_channel</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">])</span>
        <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">amp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">phase_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span> <span class="o">=</span> <span class="n">amp_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="n">xres_phase</span><span class="p">,</span> <span class="n">yres_phase</span> <span class="o">=</span> <span class="n">phase_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xres_amp</span> <span class="o">!=</span> <span class="n">xres_phase</span> <span class="ow">or</span> <span class="n">yres_amp</span> <span class="o">!=</span> <span class="n">yres_phase</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The data of the specified channels has different resolution!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span>
        <span class="n">flattened_amp</span> <span class="o">=</span> <span class="n">amp_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">flattened_amp</span><span class="p">)</span>

        <span class="n">frames</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">framenumbers</span><span class="p">):</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">framenumbers</span>
            <span class="n">repixels</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">colorpixels</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">repixval</span><span class="o">=</span><span class="n">amp_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">phase</span><span class="p">)</span><span class="o">/</span><span class="n">maxval</span>
                    <span class="n">repixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repixval</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">XRes</span><span class="p">,</span><span class="n">YRes</span><span class="p">))</span>
            <span class="c1"># img = Image.fromarray(repixels)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">putdata</span><span class="p">(</span><span class="n">repixels</span><span class="p">,</span><span class="mi">256</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">putpalette</span><span class="p">(</span><span class="n">realcolorpalette</span><span class="p">)</span>
            <span class="c1">#img=img.rotate(angle)</span>
            <span class="c1">#img=img.crop([int(YRes*np.sin(absangle)),int(XRes*np.sin(absangle)),int(XRes-YRes*np.sin(absangle)),int(YRes-XRes*np.sin(absangle))])</span>
            <span class="c1">#img.putdata(colorpixels,256,0)</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span> <span class="o">+</span> <span class="n">demodulation</span> <span class="o">+</span> <span class="s1">&#39;R&#39;</span>
        <span class="c1"># self.filename is actually a windows path element not a str filename, to get the string use: self.filename.name</span>
        <span class="c1"># print(&#39;savefile path: &#39;, self.directory_name / Path(self.filename.name + f&#39;{channel}_gif.gif&#39;))</span>
        <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_gif_old.gif&#39;</span><span class="p">),</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;GIF&#39;</span><span class="p">,</span> <span class="n">append_images</span><span class="o">=</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">save_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">duration</span><span class="o">=</span><span class="n">Duration</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_gif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_gif_old.gif&#39;</span><span class="p">),</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span></div>


<div class="viewcode-block" id="SnomMeasurement.create_gif">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.create_gif">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amp_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
        <span class="n">framenumbers</span><span class="o">=</span><span class="n">frames</span>
        <span class="n">Duration</span><span class="o">=</span><span class="mi">1000</span><span class="o">/</span><span class="n">fps</span> <span class="c1"># in ms</span>

        <span class="n">realcolorpalette</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1"># old color palette</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">255</span><span class="p">):</span>
            <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">127</span><span class="p">):</span> <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">255</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
            <span class="n">realcolorpalette</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">255</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="c1"># convert cmap to colorpalette</span>
        <span class="c1"># realcolorpalette = SNOM_realpart</span>
        <span class="c1"># import matplotlib as mpl</span>
        <span class="c1"># norm = mpl.colors.Normalize()</span>
        <span class="c1"># from matplotlib import cm</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">amp_channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified channels are not specified as needed!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># demodulation = amp_channel[1:2]</span>
        <span class="n">demodulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_demodulation_num</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;demodulation: &#39;</span><span class="p">,</span> <span class="n">demodulation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">demodulation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels you specified are not from the same demodulation order!</span><span class="se">\n</span><span class="s1">Proceeding anyways...&#39;</span><span class="p">)</span>
        <span class="c1"># check if channels are in memory, if not load the data</span>
        <span class="k">if</span> <span class="n">amp_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">phase_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels for amplitude or phase were not found in the memory, they will be loaded automatically.</span><span class="se">\n</span><span class="s1">Be aware that all prior modifications will get deleted.&#39;</span><span class="p">)</span>
            <span class="c1"># reload all channels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">amp_channel</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">])</span>
        <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">amp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">phase_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span> <span class="o">=</span> <span class="n">amp_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="n">xres_phase</span><span class="p">,</span> <span class="n">yres_phase</span> <span class="o">=</span> <span class="n">phase_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xres_amp</span> <span class="o">!=</span> <span class="n">xres_phase</span> <span class="ow">or</span> <span class="n">yres_amp</span> <span class="o">!=</span> <span class="n">yres_phase</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The data of the specified channels has different resolution!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span>
        <span class="n">flattened_amp</span> <span class="o">=</span> <span class="n">amp_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">flattened_amp</span><span class="p">)</span>

        <span class="n">frames</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">framenumbers</span><span class="p">):</span>
            <span class="n">phase</span><span class="o">=</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">framenumbers</span>
            <span class="n">repixels</span><span class="o">=</span><span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">repixval</span><span class="o">=</span><span class="n">amp_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">phase</span><span class="p">)</span><span class="o">/</span><span class="n">maxval</span>
                    <span class="n">repixels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">repixval</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">repixels</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">SNOM_realpart</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">bytes</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span> <span class="o">+</span> <span class="n">demodulation</span> <span class="o">+</span> <span class="s1">&#39;R&#39;</span>
        <span class="c1"># self.filename is actually a windows path element not a str filename, to get the string use: self.filename.name</span>
        <span class="c1"># print(&#39;savefile path: &#39;, self.directory_name / Path(self.filename.name + f&#39;{channel}_gif.gif&#39;))</span>
        <span class="n">gif_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_gif.gif&#39;</span><span class="p">)</span>
        <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">gif_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;GIF&#39;</span><span class="p">,</span> <span class="n">append_images</span><span class="o">=</span><span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">save_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">duration</span><span class="o">=</span><span class="n">Duration</span><span class="p">,</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="c1"># plt.show()</span>
        <span class="c1"># plt.close(fig)</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_display_gif</span><span class="p">(</span><span class="n">gif_path</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gif_path</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_display_gif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gif_path</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="c1"># Load the gif</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">imageio</span><span class="o">.</span><span class="n">mimread</span><span class="p">(</span><span class="n">gif_path</span><span class="p">)</span>

        <span class="c1"># Create a figure and axis</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>

        <span class="c1"># Create a function to update the frame</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">update_image</span><span class="p">(</span><span class="n">frame</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">frame</span><span class="p">])</span>
            <span class="c1"># dont show frame around the image</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="c1"># Hide the axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;off&#39;</span><span class="p">)</span>

        <span class="c1"># Create the animation</span>
        <span class="n">ani</span> <span class="o">=</span> <span class="n">FuncAnimation</span><span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">update_image</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="p">),</span> <span class="n">interval</span><span class="o">=</span><span class="mi">1000</span><span class="o">/</span><span class="n">fps</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Display the animation</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<div class="viewcode-block" id="SnomMeasurement.create_gif_v2">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.create_gif_v2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_gif_v2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amp_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">frames</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fps</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">frame_numer</span> <span class="o">=</span> <span class="n">frames</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">amp_channel</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified channels are not specified as needed!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># demodulation = amp_channel[1:2]</span>
        <span class="n">demodulation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_demodulation_num</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)</span>
        <span class="c1"># print(&#39;demodulation: &#39;, demodulation)</span>
        <span class="k">if</span> <span class="n">demodulation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_channel</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels you specified are not from the same demodulation order!</span><span class="se">\n</span><span class="s1">Proceeding anyways...&#39;</span><span class="p">)</span>
        <span class="c1"># check if channels are in memory, if not load the data</span>
        <span class="k">if</span> <span class="n">amp_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">phase_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channels for amplitude or phase were not found in the memory, they will be loaded automatically.</span><span class="se">\n</span><span class="s1">Be aware that all prior modifications will get deleted.&#39;</span><span class="p">)</span>
            <span class="c1"># reload all channels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">amp_channel</span><span class="p">,</span> <span class="n">phase_channel</span><span class="p">])</span>
        <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">amp_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">amp_channel</span><span class="p">)]</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">phase_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">phase_channel</span><span class="p">)]</span>
        <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span> <span class="o">=</span> <span class="n">amp_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="n">xres_phase</span><span class="p">,</span> <span class="n">yres_phase</span> <span class="o">=</span> <span class="n">phase_dict</span><span class="p">[</span><span class="n">ChannelTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xres_amp</span> <span class="o">!=</span> <span class="n">xres_phase</span> <span class="ow">or</span> <span class="n">yres_amp</span> <span class="o">!=</span> <span class="n">yres_phase</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The data of the specified channels has different resolution!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span> <span class="o">=</span> <span class="n">xres_amp</span><span class="p">,</span> <span class="n">yres_amp</span>
        <span class="n">flattened_amp</span> <span class="o">=</span> <span class="n">amp_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">flattened_amp</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">SNOM_realpart</span>

        <span class="c1"># create real data for all frames</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_real_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_numer</span><span class="p">):</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">frame_numer</span>
            <span class="n">real_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">YRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">real_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="n">phase</span><span class="p">)</span><span class="o">/</span><span class="n">maxval</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_real_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">real_data</span><span class="p">)</span>

        <span class="c1"># Create figure and axis</span>
        <span class="c1"># figsize = 10</span>
        <span class="c1"># figsizex = 10</span>
        <span class="c1"># figsizey = 10*YRes/XRes</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1">#, figsize=(figsizex, figsizey)</span>
        
        <span class="c1"># Create empty list to store the frames</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Create the frames</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frame_numer</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_real_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">maxval</span><span class="o">*</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">maxval</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>
            <span class="c1"># self.cax = ax.imshow(data, cmap=cmap, aspect=&#39;equal&#39;, vmin=-maxval*1.1, vmax=maxval*1.1)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Frame </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># create colorbar only once</span>
                <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
                <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mi">2</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
            <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cax</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Ez [arb.u.]&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
            <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
            <span class="c1"># disable the black frame around the image</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># remove the whitespace around the image</span>
            <span class="c1"># ax.margins(0)</span>
            <span class="c1"># ax.margins(x=0, y=0)</span>
            <span class="c1"># ax.spines[[&#39;right&#39;, &#39;top&#39;]].set_visible(False)</span>
            <span class="c1"># disable the black frame around the colorbar</span>
            <span class="n">cbar</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">tostring_rgb</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">get_width_height</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,))</span>
            <span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>


        <span class="n">channel</span> <span class="o">=</span> <span class="s1">&#39;O&#39;</span> <span class="o">+</span> <span class="n">demodulation</span> <span class="o">+</span> <span class="s1">&#39;R&#39;</span>
        <span class="c1"># Save the frames as a gif</span>
        <span class="n">imageio</span><span class="o">.</span><span class="n">mimsave</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_gif_v2.gif&#39;</span><span class="p">),</span> <span class="n">frames</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span>
        <span class="c1"># alternative:</span>
        <span class="c1"># import imageio.v3 as iio</span>
        <span class="c1"># iio.imwrite(self.directory_name / Path(self.filename.name + f&#39;{channel}_gif_withimwrite.gif&#39;), frames, fps=fps)</span>
        <span class="c1"># try with writer:</span>
        <span class="c1"># writer = imageio.get_writer(self.directory_name / Path(self.filename.name + f&#39;{channel}_gif_with_writer.gif&#39;), fps = fps)</span>

        <span class="c1"># for im in frames:</span>
        <span class="c1">#     writer.append_data(im)</span>
        <span class="c1"># writer.close()</span>

        <span class="c1"># delete the figure</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span>
        <span class="c1"># display the gif</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_gif</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">channel</span><span class="si">}</span><span class="s1">_gif_v2.gif&#39;</span><span class="p">),</span> <span class="n">fps</span><span class="o">=</span><span class="n">fps</span><span class="p">)</span></div>


<div class="viewcode-block" id="SnomMeasurement.substract_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.substract_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">substract_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel1</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channel2</span><span class="p">:</span><span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">or</span> <span class="n">channel2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified channels are not in memory, they will be loaded automatically.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_data</span><span class="p">([</span><span class="n">channel1</span><span class="p">,</span> <span class="n">channel2</span><span class="p">])</span>
        <span class="n">data1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel1</span><span class="p">)]</span>
        <span class="n">data2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">data1</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">data2</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The data of the specified channels has different resolution!&#39;</span><span class="p">)</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">data1</span> <span class="o">-</span> <span class="n">data2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel1</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="n">channel2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel1</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel1</span> <span class="o">+</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="n">channel2</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_select_data_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will use the data range selector to select a range of data. If use_memory is True the function will use the data from memory for the specified channel.</span>
<span class="sd">        In that case it will ignore the data argument. If use_memory is False the function will use the data argument and ignore the channel argument. The channel argument is only</span>
<span class="sd">        used to get the correct colormap. The function will return the selected data.</span>
<span class="sd">        Either one or two arrays will be returned depending on the selection.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Data array to select the range from. Defaults to None.</span>
<span class="sd">            channel (str): Channel name to get the data from memory or/and colormap from. Defaults to None.</span>
<span class="sd">            use_memory (bool, optional): If True the function will use the data from memory for the specified channel. Defaults to True.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of one or two arrays containing the selected data depending on the selection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># identify the data to use for the range selection</span>
        <span class="k">if</span> <span class="n">use_memory</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No data was specified!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># get the range selection</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_horizontal</span><span class="p">,</span> <span class="n">inverted</span> <span class="o">=</span> <span class="n">select_data_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">is_horizontal</span><span class="p">,</span> <span class="n">inverted</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_data_from_selected_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">is_horizontal</span><span class="p">:</span><span class="nb">bool</span><span class="p">,</span> <span class="n">inverted</span><span class="p">:</span><span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will return one or two arrays from the data using the coordinates of the range selection.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (np.ndarray): Data array to create the array/s from.</span>
<span class="sd">            start (int): Start coordinate of the range selection.</span>
<span class="sd">            end (int): End coordinate of the range selection.</span>
<span class="sd">            is_horizontal (bool): Boolean to indicate if the range selection is horizontal.</span>
<span class="sd">            inverted (bool): Bollean to indicate if the range selection is inverted.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: The list contains one or two arrays depending on the selection. Each array contains the selected data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start, end, is_horizontal, inverted = self._select_data_range(channel, data, use_memory)</span>
        <span class="c1"># create one or two arrays from the data using the coordinates</span>
        <span class="n">reduced_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">is_horizontal</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inverted</span><span class="p">:</span>
                <span class="n">left_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,:</span><span class="n">start</span><span class="p">]</span>
                <span class="n">right_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">end</span><span class="p">:]</span>
                <span class="n">reduced_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left_data</span><span class="p">)</span>
                <span class="n">reduced_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selected_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="n">reduced_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">selected_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inverted</span><span class="p">:</span>
                <span class="n">top_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">start</span><span class="p">,:]</span>
                <span class="n">bottom_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">end</span><span class="p">:,:]</span>
                <span class="n">reduced_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top_data</span><span class="p">)</span>
                <span class="n">reduced_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bottom_data</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selected_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,:]</span>
        <span class="k">return</span> <span class="n">reduced_data</span>
    
<div class="viewcode-block" id="SnomMeasurement.level_data_columnwise">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.level_data_columnwise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">level_data_columnwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel_list</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will level the data of the specified channels columnwise. The function will use the data from the display channel to select the range for leveling.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): Channels from memory which should be leveled. Defaults to None.</span>
<span class="sd">            display_channel (str, optional): Channel to use to select the range for leveling. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># todo sofar only for the horizontal selection (slow drifts), maybe problematic if the data was rotated...</span>
        <span class="c1"># todo does not work yet for phase and amplitude channels</span>
        <span class="k">if</span> <span class="n">channel_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No channels specified, using all channels in memory.&#39;</span><span class="p">)</span>
            <span class="n">channel_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># make sure to use a copy for the iteration, because the list will be modified</span>
        <span class="k">if</span> <span class="n">display_channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># get the selection from the display channel</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_select_data_range</span><span class="p">(</span><span class="n">display_channel</span><span class="p">)</span>
        <span class="c1"># now use the selection to level all channels</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channel_list</span><span class="p">:</span>
            <span class="c1"># get the data from memory</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
            <span class="c1"># get the reduced data</span>
            <span class="n">reduced_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_from_selected_range</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">selection</span><span class="p">)</span>
            <span class="c1"># level the data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;leveling with one reference area&#39;</span><span class="p">)</span>
                <span class="c1"># get the reference data from the mean of the reduced data for each row</span>
                <span class="n">reference_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># create the leveled data</span>
                <span class="n">leveled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># leveled_data[i] = data[i] - reference_data[i]</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mean_drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reference_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_drift</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;leveling with two reference areas&#39;</span><span class="p">)</span>
                <span class="c1"># get the reference data from the mean of the reduced data for each column and for both sides</span>
                <span class="n">reference_data_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">reference_data_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reduced_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># create the leveled data by interpolating between the two reference data arrays and subtracting them from the data</span>
                <span class="n">leveled_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="c1"># if phase is leveled make sure no phase jumps occur otherwise the leveling will not work</span>
                    <span class="c1"># first correct the overall drift of the mean per line</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mean_drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">reference_data_left</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reference_data_right</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">reference_data_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_data_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                        <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_drift</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># then correct the drift within each individual line by interpolating between the two reference data arrays</span>
                    <span class="n">line_drift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">reference_data_left</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">reference_data_right</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                    <span class="c1"># shift line_drift such that the mean is zero</span>
                    <span class="n">line_drift</span> <span class="o">=</span> <span class="n">line_drift</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">line_drift</span><span class="p">)</span>
                    <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">leveled_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">line_drift</span>
            <span class="c1"># if phase channel, shift the data to match the leveled data to the original data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="c1"># todo, for now just shift by 0 to make sure the data is within the 0 to 2pi range</span>
                <span class="c1"># shift the data such that the mean is pi</span>
                <span class="n">mean_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">leveled_data</span><span class="p">)</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">mean_phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="n">leveled_data</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>
<span class="w">            </span><span class="sd">&#39;&#39;&#39;# save the leveled data, add the leveled data to memory and keep old data</span>
<span class="sd">            self.channels.append(channel + &#39;_leveled&#39;)</span>
<span class="sd">            self.all_data.append(leveled_data)</span>
<span class="sd">            self.channel_tag_dict.append(self.channel_tag_dict[self.channels.index(channel)])</span>
<span class="sd">            self.channels_label.append(channel + &#39;_leveled&#39;)&#39;&#39;&#39;</span>
            <span class="c1"># save the leveled data and replace old data</span>
            <span class="c1"># keep original channel name, but change the data and the channels_label</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="n">leveled_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span> <span class="o">=</span> <span class="n">channel</span> <span class="o">+</span> <span class="s1">&#39;_leveled&#39;</span></div>


<div class="viewcode-block" id="SnomMeasurement.create_new_channel">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.create_new_channel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_new_channel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">channel_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channel_tag_dict</span><span class="p">:</span><span class="nb">dict</span><span class="p">,</span> <span class="n">channel_label</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel_label</span> <span class="o">=</span> <span class="n">channel_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_tag_dict</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_tag_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel_label</span><span class="p">)</span></div>


    <span class="c1"># not yet fully implemented, eg. the profile plot function is only ment for full horizontal or vertical profiles only</span>
<div class="viewcode-block" id="SnomMeasurement.test_profile_selection">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.SnomMeasurement.test_profile_selection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">test_profile_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">array_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)]</span>
        <span class="c1"># x, y = np.mgrid[-0:100:1, 0:200:1]</span>
        <span class="c1"># z = np.sqrt(x**2 + y**2) + np.sin(x**2 + y**2)</span>
        <span class="c1"># z = np.sin(x/2)*np.exp(-x/100)</span>
        <span class="c1"># array_2d = z</span>
        <span class="c1"># plt.pcolormesh(array_2d)</span>
        <span class="c1"># plt.show()</span>
        <span class="n">profile</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">select_profile</span><span class="p">(</span><span class="n">array_2d</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">profile</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">profile</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">width</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;self.profile_channel = channel</span>
<span class="sd">        self.profiles = [profile]</span>
<span class="sd">        # find out the orientation of the profile</span>
<span class="sd">        if start[0] == end[0]:</span>
<span class="sd">            self.profile_orientation = Definitions.horizontal</span>
<span class="sd">        elif start[1] == end[1]:</span>
<span class="sd">            self.profile_orientation = Definitions.vertical</span>
<span class="sd">        else:</span>
<span class="sd">            self.profile_orientation = &#39;unknown&#39;</span>
<span class="sd">            print(&#39;The profile orientation could not be determined!&#39;)&#39;&#39;&#39;</span></div>
</div>


<div class="viewcode-block" id="ApproachCurve">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ApproachCurve">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ApproachCurve</span><span class="p">(</span><span class="n">FileHandler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class opens an approach curve measurement and handels all the approach curve related functions.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_name</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;M1A&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">directory_name</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="mi">27</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_measurement_channel_indicators</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_initialize_measurement_channel_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;M1P&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_channels_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;amp_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backwards_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;backwards_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;real_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imag_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;imag_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optical_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;optical_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_indicator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;mechanical_indicator&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_prefix_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_prefix_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_prefix_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_manipulated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_manipulated&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_overlain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;channel_suffix_overlain&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_ending</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;file_ending&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_offset_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_offset_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;phase_offset_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_amp_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_amp_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_amp_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_phase_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_phase_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_phase_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_complex_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_complex_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_complex_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_height_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rounding_decimal_height_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;rounding_decimal_height_custom&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_scaling_default&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_scaling_custom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_from_config</span><span class="p">(</span><span class="s1">&#39;height_scaling_custom&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">datafile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
        <span class="n">x_channel_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_index</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">file</span> <span class="p">,</span><span class="n">skip_header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">x_channel_index</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">invalid_raise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">xdata</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">channel_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_index</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">y_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">file</span> <span class="p">,</span><span class="n">skip_header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">channel_index</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">invalid_raise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_data</span>
        <span class="c1"># scale the x data to nm</span>
        <span class="n">x_scaling</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">x_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>

        <span class="c1"># we want to convert the xaxis to nm</span>
        <span class="k">if</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[nm]&#39;</span><span class="p">:</span>
            <span class="n">x_scaling</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
                <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># ok forget about that, the software from neaspec saves the scan area parameters as m but the actual data is stored in m...</span>
        <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># scale xdata:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">],</span> <span class="n">x_scaling</span><span class="p">)</span>

<div class="viewcode-block" id="ApproachCurve.set_min_to_zero">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ApproachCurve.set_min_to_zero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_min_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># set the min of the xdata array to zero</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">])</span> <span class="c1"># for some reason at least the first value seems to be nan </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_x</span></div>


<div class="viewcode-block" id="ApproachCurve.display_channels">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ApproachCurve.display_channels">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">y_channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">x_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">y_channels</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>

        <span class="c1"># labels for axes:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z [nm]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="ApproachCurve.display_channels_v2">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ApproachCurve.display_channels_v2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_channels_v2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">x_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="k">if</span> <span class="n">y_channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">y_channels</span><span class="p">:</span>
            <span class="n">y_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_approach_curve</span><span class="p">(</span><span class="n">x_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">],</span> <span class="n">y_data</span><span class="o">=</span><span class="n">y_data</span><span class="p">,</span> <span class="n">x_channel</span><span class="o">=</span><span class="n">x_channel</span><span class="p">,</span> <span class="n">y_channels</span><span class="o">=</span><span class="n">y_channels</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_display_approach_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span> <span class="n">x_channel</span><span class="p">,</span> <span class="n">y_channels</span><span class="p">):</span>        
        <span class="c1"># import matplotlib.colors as mcolors</span>
        <span class="c1"># colors = mcolors.TABLEAU_COLORS</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tab:blue&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:orange&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:green&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:red&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:purple&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:olive&#39;</span><span class="p">]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># deactivate ticks for all except the first or it will get messy</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">line1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="c1"># ignore the first as it was plotted already</span>
                <span class="c1"># i = self.channels.index(channel)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">y_channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelright</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">)</span>

        <span class="c1"># labels for axes:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z [nm]&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>


<div class="viewcode-block" id="ApproachCurve.find_index">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.ApproachCurve.find_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="n">split_line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">split_line</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">split_line</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span></div>
</div>


<div class="viewcode-block" id="Scan3D">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Scan3D</span><span class="p">(</span><span class="n">FileHandler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A 3D scan is a measurement where one approach curve is saved per pixel. This class is ment to handle such measurements.</span>

<span class="sd">    Args:</span>
<span class="sd">        FileHandler (_type_): _description_</span>

<span class="sd">    Returns:</span>
<span class="sd">        _type_: _description_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># set channelname if none is given</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;O2A&#39;</span><span class="p">]</span> <span class="c1"># if you want to plot approach curves &#39;Z&#39; must be included!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="c1"># call the init constructor of the filehandler class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">directory_name</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="c1"># define header, probably same as for approach curve</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="mi">27</span>
        <span class="c1"># initialize the channel indicators</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;filetype: &#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_measurement_channel_indicators</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_measurement_channel_indicators</span><span class="p">()</span>
        <span class="c1"># for some reason the naming convention does not always follow the default for the snom measurements of the same filetype</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_create_channel_tag_dict</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channel_suffix_default</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_create_channel_tag_dict</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The channel tag dict could not be created!&#39;</span><span class="p">)</span>
                <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># load the channels from the datafile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">()</span>

    
    <span class="k">def</span><span class="w"> </span><span class="nf">_update_measurement_channel_indicators</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Z&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mechanical_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;M1A&#39;</span><span class="p">,</span> <span class="s1">&#39;M1P&#39;</span><span class="p">]</span> <span class="c1"># todo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;O1P&#39;</span><span class="p">,</span><span class="s1">&#39;O2P&#39;</span><span class="p">,</span><span class="s1">&#39;O3P&#39;</span><span class="p">,</span><span class="s1">&#39;O4P&#39;</span><span class="p">,</span><span class="s1">&#39;O5P&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">amp_channels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;O1A&#39;</span><span class="p">,</span><span class="s1">&#39;O2A&#39;</span><span class="p">,</span><span class="s1">&#39;O3A&#39;</span><span class="p">,</span><span class="s1">&#39;O4A&#39;</span><span class="p">,</span><span class="s1">&#39;O5A&#39;</span><span class="p">]</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">datafile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directory_name</span> <span class="o">/</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.txt&#39;</span><span class="p">)</span>
        <span class="c1"># initialize all data dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># (key, value) = (channelname, 3d matrix, shape:(xres, yres, zres)) </span>
        <span class="c1"># load the data per channel and add to all_data</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">find_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span> <span class="c1"># find the index of the channels</span>
            <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">file</span> <span class="p">,</span><span class="n">skip_header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">invalid_raise</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
        <span class="c1"># scale the x data to nm</span>
        <span class="n">x_scaling</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># try: x_unit = self.measurement_tag_dict[MeasurementTags.SCANAREA][0]</span>
        <span class="n">x_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># except: x_unit = None</span>
        <span class="c1"># else:</span>
        <span class="c1"># we want to convert the xaxis to nm</span>
        <span class="k">if</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[nm]&#39;</span><span class="p">:</span>
            <span class="n">x_scaling</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">x_unit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
                <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># ok forget about that, the software from neaspec saves the scan area parameters as m but the actual data is stored in m...</span>
        <span class="n">x_scaling</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span>
        <span class="c1"># scale xdata:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">],</span> <span class="n">x_scaling</span><span class="p">)</span>

<div class="viewcode-block" id="Scan3D.set_min_to_zero">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.set_min_to_zero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_min_to_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># set the min of the xdata array to zero</span>
        <span class="n">min_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">])</span> <span class="c1"># for some reason at least the first value seems to be nan </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_x</span></div>


<div class="viewcode-block" id="Scan3D.get_cutplane_data">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.get_cutplane_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_cutplane_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">cutplane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                    <span class="n">cutplane_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cutplane_data</span></div>


<div class="viewcode-block" id="Scan3D.generate_all_cutplane_data">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.generate_all_cutplane_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_all_cutplane_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cutplane_data</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span></div>


<div class="viewcode-block" id="Scan3D.display_cutplane">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_cutplane">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_cutplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># todo: shift each y column by offset value depending on average z position, to correct for varying starting position, due to non flat substrates</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cutplane_data</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>

        <span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Scan3D.display_cutplane_v2">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_cutplane_v2">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_cutplane_v2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cutplane_data</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">channel</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="c1"># todo: shift each y column by offset value depending on average z position, to correct for varying starting position, due to non flat substrates</span>
        <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># idea: get all the lowest points of the approach curves and shift them to the same z position, herefore we shift them only upwards relative to the lowest point</span>
        <span class="n">z_data_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span>
        <span class="c1"># reshape the data to the correct shape</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                    <span class="n">z_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_data_raw</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_z_shift_</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># z_data is in nm</span>
        <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">)</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span> <span class="o">-</span> <span class="n">z_min</span>
        <span class="c1"># now we need to shift each approach curve by the corresponding z_shift</span>
        <span class="c1"># therefore we need to create a new data array which can encorporate the shifted data</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ZR: &#39;</span><span class="p">,</span> <span class="n">ZRes</span><span class="p">)</span>
        <span class="c1"># XRange, YRange, ZRange = self.measurement_tag_dict[MeasurementTags.SCANAREA]</span>
        <span class="n">XRange</span><span class="p">,</span> <span class="n">YRange</span><span class="p">,</span> <span class="n">ZRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># XYZUnit = self.parameters_dict[&#39;Scan Area (X, Y, Z)&#39;][-1]</span>
        <span class="n">XYZUnit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># convert Range to nm</span>
        <span class="k">if</span> <span class="n">XYZUnit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">XRange</span> <span class="o">=</span> <span class="n">XRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">YRange</span> <span class="o">=</span> <span class="n">YRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">ZRange</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">*</span><span class="mf">1e3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error! The unit of the scan area is not supported yet!&#39;</span><span class="p">)</span>
        <span class="n">z_pixelsize</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">/</span><span class="n">ZRes</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;z_shifts: &#39;</span><span class="p">,</span> <span class="n">z_shifts</span><span class="p">)</span>
        <span class="c1"># calculate the new z range</span>
        <span class="n">ZRange_new</span> <span class="o">=</span> <span class="n">ZRange</span> <span class="o">+</span> <span class="n">z_shifts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">ZRes_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ZRange_new</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ZRes_new: &#39;</span><span class="p">,</span> <span class="n">ZRes_new</span><span class="p">)</span>
        <span class="c1"># create the new data array</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ZRes_new</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRes</span><span class="p">):</span>
                <span class="n">cutplane_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This shifting is not optimal, since a slow drift or a tilt of the sample would lead to a wrong alignment of the approach curves, although they start at the bottom.</span>
<span class="sd">        Maybe try to use a 2d scan of the same region to align the approach curves.&#39;&#39;&#39;</span>
        
        <span class="c1"># import plotting_parameters.json, here the user can tweek some options for the plotting, like automatic titles and colormap choices</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_parameters</span><span class="p">()</span>

        <span class="c1"># update the placeholders in the dictionary</span>
        <span class="c1"># the dictionary contains certain placeholders, which are now being replaced with the actual values</span>
        <span class="c1"># until now only the channel placeholder is used but more could be added</span>
        <span class="c1"># placeholders are indicated by the &#39;&lt;&#39; and &#39;&gt;&#39; characters</span>
        <span class="c1"># this step insures, that for example the title contains the correct channel name</span>
        <span class="n">placeholders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&lt;channel&gt;&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="n">plotting_parameters</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>

        <span class="c1"># set colormap depending on channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_title&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># size is the size of colorbar relative to original axis, 100% means same size, 10% means 10% of original</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="c1"># plt.colorbar(img)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Scan3D.display_cutplane_v3">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_cutplane_v3">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_cutplane_v3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
        <span class="c1"># sadly the data definitions for this filytype are off, eg. missing &#39;raw&#39; suffix for 3D scan, also the channel headers are incomplete, z res is false</span>
        <span class="c1"># XRes, YRes, ZRes = self._get_channel_tag_dict_value(channel, ChannelTags.PIXELAREA)</span>
        <span class="c1"># therefore we use the measurement tag dict</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>

        <span class="c1"># YRes, XRes = cutplane_data.shape # cutplane data might have been</span>
        <span class="n">XRange</span><span class="p">,</span> <span class="n">YRange</span><span class="p">,</span> <span class="n">ZRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="n">XYZUnit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># convert Range to nm</span>
        <span class="k">if</span> <span class="n">XYZUnit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">XRange</span> <span class="o">=</span> <span class="n">XRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">YRange</span> <span class="o">=</span> <span class="n">YRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">ZRange</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">*</span><span class="mf">1e3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error! The unit of the scan area is not supported yet!&#39;</span><span class="p">)</span>
        <span class="n">z_pixelsize</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">/</span><span class="n">ZRes</span>

        <span class="c1"># now we can try to shift each approach curve by the corresponding z_shift</span>
        <span class="c1"># easiest way is to use the z start position of each approach curve</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">XRes</span><span class="p">)</span>
            <span class="c1"># idea: get all the lowest points of the approach curves and shift them to the same z position, herefore we shift them only upwards relative to the lowest point</span>
            <span class="n">z_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span>
            <span class="c1"># reshape the data to the correct shape</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                <span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_z_shift_</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># z_data is in nm</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">)</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span> <span class="o">-</span> <span class="n">z_min</span>
            <span class="c1"># therefore we need to create a new data array which can encorporate the shifted data</span>
            <span class="c1"># calculate the new z range</span>
            <span class="n">ZRange_new</span> <span class="o">=</span> <span class="n">ZRange</span> <span class="o">+</span> <span class="n">z_shifts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ZRes_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ZRange_new</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)</span>
            <span class="c1"># print(&#39;ZRes_new: &#39;, ZRes_new)</span>
            <span class="c1"># create the new data array</span>
            <span class="n">cutplane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ZRes_new</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRes</span><span class="p">):</span>
                    <span class="n">cutplane_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># This shifting is not optimal, since a slow drift or a tilt of the sample would lead to a wrong alignment of the approach curves, although they start at the bottom.</span>
            <span class="c1"># Maybe try to use a 2d scan of the same region to align the approach curves.</span>
        
        <span class="c1"># import plotting_parameters.json, here the user can tweek some options for the plotting, like automatic titles and colormap choices</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_parameters</span><span class="p">()</span>

        <span class="c1"># update the placeholders in the dictionary</span>
        <span class="c1"># the dictionary contains certain placeholders, which are now being replaced with the actual values</span>
        <span class="c1"># until now only the channel placeholder is used but more could be added</span>
        <span class="c1"># placeholders are indicated by the &#39;&lt;&#39; and &#39;&gt;&#39; characters</span>
        <span class="c1"># this step insures, that for example the title contains the correct channel name</span>
        <span class="n">placeholders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&lt;channel&gt;&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="n">plotting_parameters</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>

        <span class="c1"># set colormap depending on channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_title&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># size is the size of colorbar relative to original axis, 100% means same size, 10% means 10% of original</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="c1"># plt.colorbar(img)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tight_layout</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="Scan3D.display_cutplane_v2_realpart">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_cutplane_v2_realpart">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_cutplane_v2_realpart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">demodulation</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        
        <span class="n">amp_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">A&#39;</span>
        <span class="n">phase_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">P&#39;</span>
        <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">amp_channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">phase_channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">cutplane_amp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> 
            <span class="n">cutplane_phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                    <span class="n">cutplane_amp_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">cutplane_phase_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># todo: shift each y column by offset value depending on average z position, to correct for varying starting position, due to non flat substrates</span>
        <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># idea: get all the lowest points of the approach curves and shift them to the same z position, herefore we shift them only upwards relative to the lowest point</span>
        <span class="n">z_data_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span>
        <span class="c1"># reshape the data to the correct shape</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">z_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">z</span><span class="p">,</span><span class="n">x</span><span class="p">))</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
                    <span class="n">z_data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_data_raw</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_z_shift_</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
        <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">)</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span> <span class="o">-</span> <span class="n">z_min</span>
        <span class="c1"># now we need to shift each approach curve by the corresponding z_shift</span>
        <span class="c1"># therefore we need to create a new data array which can encorporate the shifted data</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ZR: &#39;</span><span class="p">,</span> <span class="n">ZRes</span><span class="p">)</span>
        <span class="n">XRange</span><span class="p">,</span> <span class="n">YRange</span><span class="p">,</span> <span class="n">ZRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="n">XYZUnit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># convert Range to nm</span>
        <span class="k">if</span> <span class="n">XYZUnit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">XRange</span> <span class="o">=</span> <span class="n">XRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">YRange</span> <span class="o">=</span> <span class="n">YRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">ZRange</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">*</span><span class="mf">1e3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error! The unit of the scan area is not supported yet!&#39;</span><span class="p">)</span>
        <span class="n">z_pixelsize</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">/</span><span class="n">ZRes</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;z_shifts: &#39;</span><span class="p">,</span> <span class="n">z_shifts</span><span class="p">)</span>
        <span class="c1"># calculate the new z range</span>
        <span class="n">ZRange_new</span> <span class="o">=</span> <span class="n">ZRange</span> <span class="o">+</span> <span class="n">z_shifts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">ZRes_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ZRange_new</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ZRes_new: &#39;</span><span class="p">,</span> <span class="n">ZRes_new</span><span class="p">)</span>
        <span class="c1"># create the new data array</span>
        <span class="n">cutplane_real_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ZRes_new</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRes</span><span class="p">):</span>
                <span class="n">cutplane_real_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">amp_data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phase_data</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="c1"># set the channel </span>
        <span class="n">channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">Re&#39;</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This shifting is not optimal, since a slow drift or a tilt of the sample would lead to a wrong alignment of the approach curves, although they start at the bottom.</span>
<span class="sd">        Maybe try to use a 2d scan of the same region to align the approach curves.&#39;&#39;&#39;</span>
        
        <span class="c1"># import plotting_parameters.json, here the user can tweek some options for the plotting, like automatic titles and colormap choices</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_parameters</span><span class="p">()</span>

        <span class="c1"># update the placeholders in the dictionary</span>
        <span class="c1"># the dictionary contains certain placeholders, which are now being replaced with the actual values</span>
        <span class="c1"># until now only the channel placeholder is used but more could be added</span>
        <span class="c1"># placeholders are indicated by the &#39;&lt;&#39; and &#39;&gt;&#39; characters</span>
        <span class="c1"># this step insures, that for example the title contains the correct channel name</span>
        <span class="n">placeholders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&lt;channel&gt;&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="n">plotting_parameters</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>

        <span class="c1"># set colormap depending on channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_title_real&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cutplane_real_data</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_real_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">max_val</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_val</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># size is the size of colorbar relative to original axis, 100% means same size, 10% means 10% of original</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="c1"># plt.colorbar(img)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    
<div class="viewcode-block" id="Scan3D.display_cutplane_v3_realpart">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_cutplane_v3_realpart">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_cutplane_v3_realpart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">demodulation</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">):</span>
        
        <span class="n">amp_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">A&#39;</span>
        <span class="n">phase_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">P&#39;</span>
        <span class="n">real_channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">Re&#39;</span>
        <span class="c1"># set the channel </span>
        <span class="n">channel</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">Re&#39;</span>
        <span class="k">if</span> <span class="n">channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># create real part cutplane data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">real_channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">A&#39;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;O</span><span class="si">{</span><span class="n">demodulation</span><span class="si">}</span><span class="s1">P&#39;</span><span class="p">]))</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">real_channel</span><span class="p">]</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="n">XRange</span><span class="p">,</span> <span class="n">YRange</span><span class="p">,</span> <span class="n">ZRange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="n">XYZUnit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_unit</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">SCANAREA</span><span class="p">)</span>
        <span class="c1"># convert Range to nm</span>
        <span class="k">if</span> <span class="n">XYZUnit</span> <span class="o">==</span> <span class="s1">&#39;[m]&#39;</span><span class="p">:</span>
            <span class="n">XRange</span> <span class="o">=</span> <span class="n">XRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">YRange</span> <span class="o">=</span> <span class="n">YRange</span><span class="o">*</span><span class="mf">1e3</span>
            <span class="n">ZRange</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">*</span><span class="mf">1e3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error! The unit of the scan area is not supported yet!&#39;</span><span class="p">)</span>
        <span class="n">z_pixelsize</span> <span class="o">=</span> <span class="n">ZRange</span><span class="o">/</span><span class="n">ZRes</span>

        <span class="c1"># now we can try to shift each approach curve by the corresponding z_shift</span>
        <span class="c1"># easiest way is to use the z start position of each approach curve</span>
        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">XRes</span><span class="p">)</span>
            <span class="c1"># idea: get all the lowest points of the approach curves and shift them to the same z position, herefore we shift them only upwards relative to the lowest point</span>
            <span class="n">z_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x_channel</span><span class="p">]</span>
            <span class="c1"># reshape the data to the correct shape</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                <span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_z_shift_</span><span class="p">(</span><span class="n">z_data</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># z_data is in nm</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">)</span>
            <span class="n">z_shifts</span> <span class="o">=</span> <span class="n">z_shifts</span> <span class="o">-</span> <span class="n">z_min</span>
            <span class="c1"># therefore we need to create a new data array which can encorporate the shifted data</span>
            <span class="c1"># calculate the new z range</span>
            <span class="n">ZRange_new</span> <span class="o">=</span> <span class="n">ZRange</span> <span class="o">+</span> <span class="n">z_shifts</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ZRes_new</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ZRange_new</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)</span>
            <span class="c1"># print(&#39;ZRes_new: &#39;, ZRes_new)</span>
            <span class="c1"># create the new data array</span>
            <span class="n">cutplane_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ZRes_new</span><span class="p">,</span> <span class="n">XRes</span><span class="p">))</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">real_channel</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZRes</span><span class="p">):</span>
                    <span class="n">cutplane_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">z_shifts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">z_pixelsize</span><span class="p">)][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># This shifting is not optimal, since a slow drift or a tilt of the sample would lead to a wrong alignment of the approach curves, although they start at the bottom.</span>
            <span class="c1"># Maybe try to use a 2d scan of the same region to align the approach curves.</span>
<span class="w">        </span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;This shifting is not optimal, since a slow drift or a tilt of the sample would lead to a wrong alignment of the approach curves, although they start at the bottom.</span>
<span class="sd">        Maybe try to use a 2d scan of the same region to align the approach curves.&#39;&#39;&#39;</span>
        
        <span class="c1"># import plotting_parameters.json, here the user can tweek some options for the plotting, like automatic titles and colormap choices</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_plotting_parameters</span><span class="p">()</span>

        <span class="c1"># update the placeholders in the dictionary</span>
        <span class="c1"># the dictionary contains certain placeholders, which are now being replaced with the actual values</span>
        <span class="c1"># until now only the channel placeholder is used but more could be added</span>
        <span class="c1"># placeholders are indicated by the &#39;&lt;&#39; and &#39;&gt;&#39; characters</span>
        <span class="c1"># this step insures, that for example the title contains the correct channel name</span>
        <span class="n">placeholders</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;&lt;channel&gt;&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">}</span>
        <span class="n">plotting_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_plotting_parameter_placeholders</span><span class="p">(</span><span class="n">plotting_parameters</span><span class="p">,</span> <span class="n">placeholders</span><span class="p">)</span>

        <span class="c1"># set colormap depending on channel</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;amplitude_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;phase_title&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cmap&quot;</span><span class="p">]</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_cbar_label&quot;</span><span class="p">]</span>
            <span class="n">title</span> <span class="o">=</span> <span class="n">plotting_parameters</span><span class="p">[</span><span class="s2">&quot;real_title_real&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">max_val</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">max_val</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">colorbar_width</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span> <span class="c1"># size is the size of colorbar relative to original axis, 100% means same size, 10% means 10% of original</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hide_ticks</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># remove ticks on x and y axis, they only show pixelnumber anyways, better to add a scalebar</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tight_layout</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_z_shift_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z_data</span><span class="p">):</span>
        <span class="c1"># get the average z position for each approach curve</span>
        <span class="c1"># might change in the future to a more sophisticated method</span>
        <span class="c1"># return np.mean(z_data)</span>

        <span class="c1"># return the shift of the starting point of the approach curve</span>
        <span class="k">return</span> <span class="n">z_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Scan3D.display_approach_curve">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.display_approach_curve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">display_approach_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_pixel</span><span class="p">,</span> <span class="n">y_pixel</span><span class="p">,</span> <span class="n">x_channel</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x_channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_channel</span> <span class="o">=</span> <span class="s1">&#39;Z&#39;</span>
        <span class="k">if</span> <span class="n">x_channel</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The specified x channel is not in the channels of the measurement! Can not display approach curve.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">y_channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">x_channel</span><span class="p">][</span><span class="n">y_pixel</span><span class="p">][</span><span class="n">x_pixel</span><span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">y_channels</span><span class="p">:</span>
            <span class="n">y_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">y_pixel</span><span class="p">][</span><span class="n">x_pixel</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display_approach_curve</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">,</span> <span class="n">x_channel</span><span class="p">,</span> <span class="n">y_channels</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_display_approach_curve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span> <span class="n">x_channel</span><span class="p">,</span> <span class="n">y_channels</span><span class="p">):</span>
        
        <span class="c1"># x_channel = &#39;Depth&#39;</span>
        
        <span class="c1"># import matplotlib.colors as mcolors</span>
        <span class="c1"># colors = mcolors.TABLEAU_COLORS</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tab:blue&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:orange&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:green&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:red&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:purple&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:olive&#39;</span><span class="p">]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">line1</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">line2</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="p">[</span><span class="n">line1</span><span class="p">,</span> <span class="n">line2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># deactivate ticks for all except the first or it will get messy</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">line1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">y_channels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span> <span class="c1"># ignore the first as it was plotted already</span>
                <span class="c1"># i = self.channels.index(channel)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">y_channels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="c1"># plt.plot(x_data, self.all_data[channel], label=channel)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">labelright</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">line</span><span class="p">,</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_data</span><span class="p">,</span> <span class="n">y_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">channel</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="o">=</span><span class="n">handles</span><span class="p">)</span>
            
        <span class="c1"># print(x_data)</span>
        <span class="c1"># print(self.all_data[y_channels[0]])</span>
        <span class="c1"># print(self.channels)</span>

        <span class="c1"># labels for axes:</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Z [nm]&#39;</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">y_channels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># plt.xlabel(f&#39;Depth [px]&#39;)</span>
        <span class="c1"># if len(self.channels) == 1:</span>
        <span class="c1">#     plt.ylabel(self.channels[0])</span>
        <span class="c1"># plt.legend()</span>
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">PlotDefinitions</span><span class="o">.</span><span class="n">show_plot</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

<div class="viewcode-block" id="Scan3D.match_phase_offset">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.match_phase_offset">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">match_phase_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_channel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference_area</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">manual_width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function matches the phase offset of all phase channels in memory to the reference channel.</span>
<span class="sd">        The reference channel is the first phase channel in memory if not specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            channels (list, optional): list of channels, will override the already existing channels</span>
<span class="sd">            reference_channel ([type], optional): The reference channel to which all other phase channels will be matched.</span>
<span class="sd">                If not specified the first phase channel in memory will be used. Defaults to None.</span>
<span class="sd">            reference_area ([type], optional): The area in the reference channel which will be used to calculate the phase offset. If not specified the whole image will be used.</span>
<span class="sd">                You can also specify &#39;manual&#39; then you will be asked to click on a point in the image. The area around that pixel will then be used as reference. Defaults to None.</span>
<span class="sd">            manual_width (int, optional): The width of the manual reference area. Only applies if reference_area=&#39;manual&#39;. Defaults to 5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if a list of channels is specified those will be loaded and the old ones will be overwritten</span>
        <span class="c1"># self._initialize_data(channels)</span>
        <span class="c1"># define local list of channels to use for leveling</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="k">if</span> <span class="n">reference_channel</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                    <span class="n">reference_channel</span> <span class="o">=</span> <span class="n">channel</span>
                    <span class="k">break</span>
        <span class="n">cutplane_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cutplane_data</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">channel</span><span class="o">=</span><span class="n">reference_channel</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_area</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># reference_area = [[xmin, xmax][ymin, ymax]]</span>
            <span class="n">reference_area</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])],[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">)]]</span>
        <span class="k">elif</span> <span class="n">reference_area</span> <span class="o">==</span> <span class="s1">&#39;manual&#39;</span><span class="p">:</span>
            <span class="c1"># use pointcklicker to get the reference area</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">cutplane_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
            <span class="n">klicker</span> <span class="o">=</span> <span class="n">clicker</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;event&quot;</span><span class="p">],</span> <span class="n">markers</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
            <span class="c1"># ax.invert_yaxis()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Please click in the area to use as reference.&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">klicker_coords</span> <span class="o">=</span> <span class="n">klicker</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()[</span><span class="s1">&#39;event&#39;</span><span class="p">]</span>
            <span class="n">klick_coordinates</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">round</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">klicker_coords</span><span class="p">]</span>
            <span class="c1"># make sure only one point is selected</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;You must specify one point which should define the reference area!&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Do you want to try again?&#39;</span><span class="p">)</span>
                <span class="n">user_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_input_bool</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">user_input</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">match_phase_offset</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">reference_channel</span><span class="p">,</span> <span class="s1">&#39;manual&#39;</span><span class="p">,</span> <span class="n">manual_width</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">exit</span><span class="p">()</span>
            <span class="n">reference_area</span> <span class="o">=</span> <span class="p">[[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">manual_width</span><span class="p">,</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">manual_width</span><span class="p">],[</span><span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">manual_width</span><span class="p">,</span> <span class="n">klick_coordinates</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">manual_width</span><span class="p">]]</span>
        
        <span class="n">reference_data</span> <span class="o">=</span> <span class="n">cutplane_data</span>
        <span class="n">reference_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">cutplane_data</span><span class="p">[</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])])</span>
        
        <span class="c1"># display the reference area</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">reference_data</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">SNOM_phase</span><span class="p">)</span>
        <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="n">cax</span> <span class="o">=</span> <span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
        <span class="n">cbar</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">cax</span><span class="p">)</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="mi">15</span>
        <span class="n">cbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">270</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>  
        <span class="n">rect</span> <span class="o">=</span> <span class="n">patches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Reference Area: &#39;</span> <span class="o">+</span> <span class="n">reference_channel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="c1"># phase_data = self.get_cutplane_data(axis=axis, line=line, channel=channel)</span>
                <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="c1"># phase_offset = np.mean(phase_data) - reference_phase</span>
                <span class="n">phase_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">phase_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_area</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])])</span> <span class="o">-</span> <span class="n">reference_phase</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="o">-</span><span class="n">phase_offset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;match_phase_offset_reference_area&#39;</span><span class="p">,</span> <span class="n">reference_area</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_shift_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function adds a phaseshift to the specified phase data. The phase data is automatically kept in the 0 to 2 pi range.</span>
<span class="sd">        Could in future be extended to show a live view of the phase data while it can be modified by a slider...</span>
<span class="sd">        e.g. by shifting the colorscale in the preview rather than the actual data...&quot;&quot;&quot;</span>
        <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="Scan3D.shift_phase">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.shift_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shift_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span><span class="nb">float</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This function will prompt the user with a preview of the first phase channel in memory.</span>
<span class="sd">        Under the preview is a slider, by changing the slider value the phase preview will shift accordingly.</span>
<span class="sd">        If you are satisfied with the shift, hit the &#39;accept&#39; button. The preview will close and the shift will</span>
<span class="sd">        be applied to all phase channels in memory.</span>

<span class="sd">        Args:</span>
<span class="sd">            shift (float, optional): If you know the shift value already, you can enter values between 0 and 2*Pi</span>
<span class="sd">            channels (list, optional): List of channels to apply the shift to, only phase channels will be shifted though.</span>
<span class="sd">                If not specified all channels in memory will be used. Defaults to None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="c1"># self._initialize_data(channels)</span>
        <span class="k">if</span> <span class="n">shift</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">shift_known</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="c1"># phase_data = np.copy(self.all_data[self.channels.index(self.preview_phasechannel)])</span>
                    <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">preview_phasechannel</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># check if corrected phase channel is present</span>
                <span class="c1"># just take the first phase channel in memory</span>
                <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                        <span class="c1"># phase_data = np.copy(self.all_data[self.channels.index(channel)])</span>
                        <span class="n">phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
                        <span class="c1"># print(len(phase_data))</span>
                        <span class="c1"># print(len(phase_data[0]))</span>
                        <span class="k">break</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">get_phase_offset</span><span class="p">(</span><span class="n">phase_data</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The phase shift you chose is:&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
            <span class="n">shift_known</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># export shift value to logfile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_logfile</span><span class="p">(</span><span class="s1">&#39;phase_shift&#39;</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
        <span class="c1"># shift all phase channels in memory</span>
        <span class="c1"># could also be implemented to shift each channel individually...</span>
        
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="c1"># print(&#39;Before phase shift: &#39;, channel)</span>
                <span class="c1"># print(&#39;Min phase value:&#39;, np.min(self.all_cutplane_data[channel]))</span>
                <span class="c1"># print(&#39;Max phase value:&#39;, np.max(self.all_cutplane_data[channel]))</span>
                <span class="c1"># self.all_data[self.channels.index(channel)] = self._shift_phase_data(self.all_data[self.channels.index(channel)], shift)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shift_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">],</span> <span class="n">shift</span><span class="p">)</span>
                <span class="c1"># print(&#39;After phase shift: &#39;, channel)</span>
                <span class="c1"># print(&#39;Min phase value:&#39;, np.min(self.all_cutplane_data[channel]))</span>
                <span class="c1"># print(&#39;Max phase value:&#39;, np.max(self.all_cutplane_data[channel]))</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>


<div class="viewcode-block" id="Scan3D.cut_data">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.cut_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cut_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>


<div class="viewcode-block" id="Scan3D.average_data">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.average_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span><span class="nb">list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">channels</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span>
        <span class="c1"># create a cutplane of the data by averaging over the y axis</span>
        <span class="c1"># create a new data array with the averaged data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">amp_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">amp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">averaged_amp_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">amp_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">averaged_amp_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">phase_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">averaged_phase_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">phase_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">averaged_phase_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">real_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">averaged_real_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">real_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">averaged_real_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">height_indicator</span> <span class="ow">in</span> <span class="n">channel</span><span class="p">:</span>
                <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span>
                <span class="n">averaged_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">all_cutplane_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">averaged_height_data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span></div>



        
        <span class="c1"># averaged_height_data = np.mean(new_data, axis=2)</span>
        <span class="c1"># # plot the averaged height data</span>
        <span class="c1"># fig, ax = plt.subplots()</span>
        <span class="c1"># ax.pcolormesh(averaged_height_data)</span>
        <span class="c1"># ax.invert_yaxis()</span>
        <span class="c1"># plt.show()</span>
        
<div class="viewcode-block" id="Scan3D.align_lines">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Scan3D.align_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">align_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># idea: take the height channel and average each approach curve, then compare the averaged lines to each other and aplly a shift to align them</span>
        <span class="n">height_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">height_channel</span><span class="p">]</span>
        <span class="n">averaged_height_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">height_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># plot the averaged height data</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">averaged_height_data</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># get the index which minimized the deviation of the height channels</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">averaged_height_data</span><span class="p">:</span>
            <span class="c1"># calculate the index which minimizes the deviation of the height data</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">realign</span><span class="o">.</span><span class="n">minimize_deviation_1d</span><span class="p">(</span><span class="n">averaged_height_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">line</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="c1"># make a new data array with the shifted data</span>
        <span class="c1"># apply the shift to all channels</span>
        <span class="n">XRes</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">)</span>
        <span class="c1"># ac_zeros = np.zeros(ZRes)</span>
        <span class="c1"># idea: create a new data array where each approach curve is shifted by the corresponding index</span>
        <span class="c1"># get the biggest differnce in indices</span>
        <span class="n">max_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="c1"># apply the shift to each channel</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">YRes</span><span class="p">,</span> <span class="n">XRes</span><span class="o">+</span><span class="n">max_shift</span><span class="p">,</span> <span class="n">ZRes</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">YRes</span><span class="p">):</span>
                <span class="n">shift</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">XRes</span><span class="p">):</span>
                    <span class="n">new_data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="o">+</span><span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">all_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="c1"># self.measurement_tag_dict[MeasurementTags.PIXELAREA] = (XRes+max_shift, YRes, ZRes)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_measurement_tag_dict_value</span><span class="p">(</span><span class="n">MeasurementTags</span><span class="o">.</span><span class="n">PIXELAREA</span><span class="p">,</span> <span class="p">[</span><span class="n">XRes</span><span class="o">+</span><span class="n">max_shift</span><span class="p">,</span> <span class="n">YRes</span><span class="p">,</span> <span class="n">ZRes</span><span class="p">])</span></div>
</div>






<span class="c1"># could be exported to external file</span>

<div class="viewcode-block" id="Set_nan_to_zero">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Set_nan_to_zero">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Set_nan_to_zero</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">:</span>
    <span class="n">xres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">yres</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yres</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xres</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;nan&#39;</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">data</span>       </div>


<span class="c1"># needed for the realign function</span>
<div class="viewcode-block" id="gauss_function">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.gauss_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">gauss_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">mu</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="n">offset</span></div>


<div class="viewcode-block" id="Get_Largest_Abs">
<a class="viewcode-back" href="../../snom_analysis.html#snom_analysis.main.Get_Largest_Abs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">Get_Largest_Abs</span><span class="p">(</span><span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val2</span><span class="p">):</span> <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val2</span><span class="p">)</span></div>

<span class="c1"># not in use, delete?</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Hans-Joachim Schill.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>